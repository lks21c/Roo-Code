# 06. 메시지 및 통신 패턴

## 목차
1. [개요](#개요)
2. [메시지 타입 시스템](#메시지-타입-시스템)
3. [이중 히스토리 시스템](#이중-히스토리-시스템)
4. [WebView 양방향 통신](#webview-양방향-통신)
5. [IPC 패턴](#ipc-패턴)
6. [MessageManager 아키텍처](#messagemanager-아키텍처)
7. [이벤트 시스템](#이벤트-시스템)
8. [Jupyter 커널 메시지 프로토콜 매핑](#jupyter-커널-메시지-프로토콜-매핑)
9. [구현 가이드](#구현-가이드)

---

## 개요

Roo-Code의 메시지 통신 시스템은 여러 계층의 메시지 프로토콜을 통해 Extension, WebView, 외부 클라이언트 간의 복잡한 상호작용을 관리합니다.

### 통신 계층 아키텍처

```
┌─────────────────────────────────────────────────────────────────────┐
│                         외부 클라이언트                                │
│                    (CLI, IDE 통합, 자동화 도구)                        │
└───────────────────────────────┬─────────────────────────────────────┘
                                │ IPC (node-ipc)
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                         IpcServer                                   │
│              ┌────────────────────────────────────┐                 │
│              │    TaskCommand / TaskEvent         │                 │
│              └────────────────────────────────────┘                 │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                      ClineProvider                                  │
│  ┌─────────────────┐    ┌─────────────────┐    ┌────────────────┐  │
│  │ ExtensionState  │    │ MessageManager  │    │  Task Stack    │  │
│  └─────────────────┘    └─────────────────┘    └────────────────┘  │
│                                                                     │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              postMessageToWebview / postStateToWebview       │   │
│  └─────────────────────────────────────────────────────────────┘   │
└───────────────────────────────┬─────────────────────────────────────┘
                                │ ExtensionMessage / WebviewMessage
                                ▼
┌─────────────────────────────────────────────────────────────────────┐
│                          WebView (React)                            │
│  ┌─────────────────┐    ┌─────────────────┐    ┌────────────────┐  │
│  │   Chat UI       │    │  Settings UI    │    │  History UI    │  │
│  └─────────────────┘    └─────────────────┘    └────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

### 핵심 메시지 유형

| 메시지 계층 | 방향 | 용도 |
|------------|------|------|
| `ClineMessage` | Task ↔ UI | AI 대화 기록 (Ask/Say) |
| `ExtensionMessage` | Extension → WebView | 상태 업데이트 |
| `WebviewMessage` | WebView → Extension | 사용자 액션 |
| `IpcMessage` | External ↔ Extension | 외부 API 통신 |
| `TaskEvent` | Task → External | 작업 이벤트 브로드캐스트 |

---

## 메시지 타입 시스템

### ClineMessage - AI 대화 메시지

AI와 사용자 간의 모든 대화를 표현하는 핵심 메시지 타입입니다.

```typescript
// packages/types/src/message.ts
export const clineMessageSchema = z.object({
  ts: z.number(),                              // 타임스탬프 (고유 식별자)
  type: z.union([z.literal("ask"), z.literal("say")]),
  ask: clineAskSchema.optional(),              // 사용자 응답 요청
  say: clineSaySchema.optional(),              // 정보성 메시지
  text: z.string().optional(),                 // 메시지 내용
  images: z.array(z.string()).optional(),      // 이미지 첨부
  partial: z.boolean().optional(),             // 스트리밍 중 부분 메시지
  reasoning: z.string().optional(),            // AI 추론 과정
  conversationHistoryIndex: z.number().optional(),
  checkpoint: z.record(z.string(), z.unknown()).optional(),
  progressStatus: toolProgressStatusSchema.optional(),
  contextCondense: contextCondenseSchema.optional(),
  contextTruncation: contextTruncationSchema.optional(),
  isProtected: z.boolean().optional(),
  apiProtocol: z.union([z.literal("openai"), z.literal("anthropic")]).optional(),
  isAnswered: z.boolean().optional(),
})

export type ClineMessage = z.infer<typeof clineMessageSchema>
```

### ClineAsk - 사용자 응답 요청 타입

```typescript
// 12가지 Ask 타입
export const clineAsks = [
  "followup",                    // 후속 질문
  "command",                     // 명령어 실행 승인
  "command_output",              // 명령어 출력 확인
  "completion_result",           // 작업 완료 확인
  "tool",                        // 도구 사용 승인
  "api_req_failed",              // API 실패 재시도
  "resume_task",                 // 작업 재개 확인
  "resume_completed_task",       // 완료 작업 재개
  "mistake_limit_reached",       // 오류 한도 도달
  "browser_action_launch",       // 브라우저 작업 승인
  "use_mcp_server",              // MCP 서버 사용 승인
  "auto_approval_max_req_reached", // 자동 승인 한도 도달
] as const
```

### Ask 타입 분류 시스템

```typescript
// 유휴 상태 - 작업이 일시 정지된 상태
export const idleAsks = [
  "completion_result",
  "api_req_failed",
  "resume_completed_task",
  "mistake_limit_reached",
  "auto_approval_max_req_reached",
] as const

// 재개 가능 상태
export const resumableAsks = ["resume_task"] as const

// 대화형 상태 - 사용자 응답 대기
export const interactiveAsks = [
  "followup",
  "command",
  "tool",
  "browser_action_launch",
  "use_mcp_server",
] as const

// 비차단 상태 - UI 업데이트용
export const nonBlockingAsks = ["command_output"] as const

// 타입 가드 함수들
export function isIdleAsk(ask: ClineAsk): ask is IdleAsk {
  return (idleAsks as readonly ClineAsk[]).includes(ask)
}

export function isInteractiveAsk(ask: ClineAsk): ask is InteractiveAsk {
  return (interactiveAsks as readonly ClineAsk[]).includes(ask)
}
```

### ClineSay - 정보성 메시지 타입

```typescript
// 21가지 Say 타입
export const clineSays = [
  // API 상태
  "api_req_started",            // API 요청 시작
  "api_req_finished",           // API 요청 완료
  "api_req_retried",            // API 재시도
  "api_req_retry_delayed",      // API 재시도 대기
  "api_req_deleted",            // API 요청 삭제

  // 메시지 유형
  "error",                      // 오류 메시지
  "text",                       // 일반 텍스트
  "image",                      // 이미지
  "reasoning",                  // 추론 과정

  // 작업 결과
  "completion_result",          // 완료 결과
  "user_feedback",              // 사용자 피드백
  "user_feedback_diff",         // 차이점 피드백
  "command_output",             // 명령어 출력
  "subtask_result",             // 서브태스크 결과

  // 브라우저
  "browser_action",             // 브라우저 작업
  "browser_action_result",      // 브라우저 결과
  "browser_session_status",     // 브라우저 세션 상태

  // MCP
  "mcp_server_request_started", // MCP 요청 시작
  "mcp_server_response",        // MCP 응답

  // 컨텍스트 관리
  "condense_context",           // 컨텍스트 압축
  "condense_context_error",     // 압축 오류
  "sliding_window_truncation",  // 슬라이딩 윈도우 잘라내기

  // 기타
  "checkpoint_saved",           // 체크포인트 저장
  "shell_integration_warning",  // 셸 통합 경고
  "rooignore_error",            // .rooignore 오류
  "diff_error",                 // diff 오류
  "codebase_search_result",     // 코드베이스 검색 결과
  "user_edit_todos",            // 사용자 TODO 수정
] as const
```

### 메시지 상태 다이어그램

```
┌─────────────────────────────────────────────────────────────────────┐
│                        Task 상태 머신                                │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌──────────┐     ask: followup/tool     ┌─────────────────┐      │
│   │  Active  │ ─────────────────────────► │   Interactive   │      │
│   │ (실행중)  │                            │  (응답 대기)     │      │
│   └──────────┘                            └─────────────────┘      │
│        │                                          │                 │
│        │ ask: completion_result                   │ user response   │
│        ▼                                          ▼                 │
│   ┌──────────┐                            ┌─────────────────┐      │
│   │   Idle   │ ◄───────────────────────── │   Resumable     │      │
│   │  (유휴)   │      ask: resume_task     │   (재개 가능)    │      │
│   └──────────┘                            └─────────────────┘      │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 이중 히스토리 시스템

Roo-Code는 두 개의 분리된 히스토리를 유지합니다.

### UI 히스토리 (clineMessages)

사용자에게 표시되는 대화 기록입니다.

```typescript
// Task.ts에서
class Task {
  clineMessages: ClineMessage[] = []

  async say(
    type: ClineSay,
    text?: string,
    images?: string[],
    partial?: boolean,
    checkpoint?: Record<string, unknown>,
    progressStatus?: ToolProgressStatus,
    reasoning?: string,
    options?: SayOptions
  ): Promise<void> {
    const message: ClineMessage = {
      ts: Date.now(),
      type: "say",
      say: type,
      text,
      images,
      partial,
      checkpoint,
      progressStatus,
      reasoning,
    }

    // 스트리밍 중에는 기존 메시지 업데이트
    if (partial) {
      const lastMessage = this.clineMessages[this.clineMessages.length - 1]
      if (lastMessage && lastMessage.partial && lastMessage.say === type) {
        lastMessage.text = text
        lastMessage.reasoning = reasoning
        await this.overwriteClineMessages(this.clineMessages)
        return
      }
    }

    this.clineMessages.push(message)
    await this.overwriteClineMessages(this.clineMessages)
  }
}
```

### API 히스토리 (apiConversationHistory)

AI API에 전송되는 실제 대화 기록입니다.

```typescript
// Task에서 관리되는 API 히스토리
interface ApiMessage {
  role: "user" | "assistant"
  content: MessageContent[]
  ts?: number                  // 타임스탬프
  isSummary?: boolean          // 압축된 요약 메시지
  condenseId?: string          // 압축 작업 ID
  isTruncationMarker?: boolean // 잘라내기 마커
  truncationId?: string        // 잘라내기 작업 ID
}

// API 히스토리는 UI 히스토리와 독립적으로 관리
// - 컨텍스트 압축 시 요약으로 대체
// - 슬라이딩 윈도우로 오래된 메시지 제거
// - 토큰 제한 내에서 유지
```

### 히스토리 동기화 패턴

```
┌─────────────────────────────────────────────────────────────────────┐
│                      히스토리 동기화                                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   clineMessages (UI)           apiConversationHistory (API)         │
│   ┌─────────────────┐         ┌─────────────────────────┐          │
│   │ user_feedback   │ ◄─────► │ { role: "user" }        │          │
│   │ text            │ ◄─────► │ { role: "assistant" }   │          │
│   │ api_req_started │         │                         │          │
│   │ api_req_finished│         │                         │          │
│   │ tool (ask)      │         │ { tool_use: ... }       │          │
│   │ command_output  │         │ { tool_result: ... }    │          │
│   │ condense_context│ ──────► │ { isSummary: true }     │          │
│   └─────────────────┘         └─────────────────────────┘          │
│                                                                     │
│   * UI 히스토리는 모든 상호작용 포함                                    │
│   * API 히스토리는 AI에게 필요한 것만 포함                              │
│   * 압축/잘라내기 시 두 히스토리 동기화 필요                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## WebView 양방향 통신

### ExtensionMessage (Extension → WebView)

```typescript
// src/shared/ExtensionMessage.ts
export interface ExtensionMessage {
  type:
    | "action"                    // UI 액션 트리거
    | "state"                     // 전체 상태 업데이트
    | "selectedImages"            // 이미지 선택
    | "theme"                     // 테마 변경
    | "workspaceUpdated"          // 워크스페이스 변경
    | "invoke"                    // 명령 호출
    | "messageUpdated"            // 메시지 업데이트
    | "mcpServers"                // MCP 서버 목록
    | "enhancedPrompt"            // 향상된 프롬프트
    | "systemPrompt"              // 시스템 프롬프트
    | "autoApprovalEnabled"       // 자동 승인 상태
    | "currentCheckpointUpdated"  // 체크포인트 업데이트
    | "showHumanRelayDialog"      // 휴먼 릴레이 다이얼로그
    | "ttsStart"                  // TTS 시작
    | "ttsStop"                   // TTS 종료
    | "acceptInput"               // 입력 수락
    | "commands"                  // 명령어 목록
    | "browserSessionUpdate"      // 브라우저 세션 업데이트
    // ... 40+ 메시지 타입

  state?: ExtensionState          // 전체 상태 객체
  action?: "chatButtonClicked" | "settingsButtonClicked" | ...
  invoke?: "newChat" | "sendMessage" | "primaryButtonClick" | ...
  clineMessage?: ClineMessage
  mcpServers?: McpServer[]
  // ... 추가 페이로드
}
```

### ExtensionState 구조

```typescript
// 전체 확장 상태
export type ExtensionState = {
  // 버전 정보
  version: string

  // 현재 대화
  clineMessages: ClineMessage[]
  currentTaskItem?: HistoryItem
  currentTaskTodos?: TodoItem[]

  // API 설정
  apiConfiguration: ProviderSettings
  currentApiConfigName?: string
  listApiConfigMeta?: ProviderSettingsEntry[]

  // 모드 설정
  mode: Mode
  customModes: ModeConfig[]

  // 자동 승인 설정
  autoApprovalEnabled: boolean
  alwaysAllowReadOnly: boolean
  alwaysAllowWrite: boolean
  alwaysAllowExecute: boolean
  alwaysAllowBrowser: boolean
  alwaysAllowMcp: boolean

  // 실험 기능
  experiments: Experiments

  // 클라우드 연동
  cloudUserInfo: CloudUserInfo | null
  cloudIsAuthenticated: boolean
  cloudOrganizations?: CloudOrganizationMembership[]

  // 기타 설정
  taskHistory: HistoryItem[]
  mcpEnabled: boolean
  browserToolEnabled: boolean
  ttsEnabled: boolean
  // ... 100+ 설정 항목
}
```

### WebviewMessage (WebView → Extension)

```typescript
// src/shared/WebviewMessage.ts
export interface WebviewMessage {
  type:
    // 작업 관리
    | "newTask"                   // 새 작업 시작
    | "askResponse"               // Ask에 대한 응답
    | "cancelTask"                // 작업 취소
    | "clearTask"                 // 작업 정리

    // 메시지 편집
    | "deleteMessage"             // 메시지 삭제
    | "deleteMessageConfirm"      // 삭제 확인
    | "submitEditedMessage"       // 편집된 메시지 제출
    | "editMessageConfirm"        // 편집 확인

    // 설정 관리
    | "saveApiConfiguration"      // API 설정 저장
    | "loadApiConfiguration"      // API 설정 로드
    | "updateSettings"            // 설정 업데이트
    | "importSettings"            // 설정 가져오기
    | "exportSettings"            // 설정 내보내기

    // MCP
    | "openMcpSettings"           // MCP 설정 열기
    | "restartMcpServer"          // MCP 서버 재시작
    | "toggleToolAlwaysAllow"     // 도구 자동 승인 토글
    | "toggleMcpServer"           // MCP 서버 토글

    // 체크포인트
    | "checkpointDiff"            // 체크포인트 차이 조회
    | "checkpointRestore"         // 체크포인트 복원

    // 브라우저
    | "testBrowserConnection"     // 브라우저 연결 테스트
    | "killBrowserSession"        // 브라우저 세션 종료
    | "openBrowserSessionPanel"   // 브라우저 패널 열기

    // 클라우드
    | "rooCloudSignIn"            // 클라우드 로그인
    | "rooCloudSignOut"           // 클라우드 로그아웃
    | "switchOrganization"        // 조직 전환

    // 마켓플레이스
    | "installMarketplaceItem"    // 마켓플레이스 아이템 설치
    | "removeInstalledMarketplaceItem" // 아이템 제거
    // ... 100+ 메시지 타입

  text?: string
  askResponse?: ClineAskResponse
  apiConfiguration?: ProviderSettings
  images?: string[]
  messageTs?: number              // 메시지 타임스탬프
  restoreCheckpoint?: boolean
  // ... 추가 페이로드
}

export type ClineAskResponse =
  | "yesButtonClicked"
  | "noButtonClicked"
  | "messageResponse"
  | "objectResponse"
```

### WebView 메시지 핸들러 구조

```typescript
// src/core/webview/webviewMessageHandler.ts
export const webviewMessageHandler = async (
  provider: ClineProvider,
  message: WebviewMessage,
  marketplaceManager?: MarketplaceManager,
) => {
  // 상태 접근 헬퍼
  const getGlobalState = <K extends keyof GlobalState>(key: K) =>
    provider.contextProxy.getValue(key)

  const updateGlobalState = async <K extends keyof GlobalState>(key: K, value: GlobalState[K]) =>
    await provider.contextProxy.setValue(key, value)

  // 메시지 타입별 처리
  switch (message.type) {
    case "newTask":
      await provider.createTask(message.text, message.images)
      break

    case "askResponse":
      const currentTask = provider.getCurrentTask()
      if (currentTask) {
        switch (message.askResponse) {
          case "yesButtonClicked":
            currentTask.approveAsk({ text: message.text, images: message.images })
            break
          case "noButtonClicked":
            currentTask.denyAsk({ text: message.text, images: message.images })
            break
          case "messageResponse":
            await currentTask.submitUserMessage(message.text || "", message.images)
            break
        }
      }
      break

    case "deleteMessage":
      await handleDeleteOperation(message.messageTs!)
      break

    case "checkpointRestore":
      await handleCheckpointRestoreOperation({
        provider,
        currentCline: provider.getCurrentTask()!,
        messageTs: message.payload!.ts,
        checkpoint: { hash: message.payload!.commitHash },
        operation: message.payload!.mode,
      })
      break

    // ... 100+ case 처리
  }
}
```

---

## IPC 패턴

### IPC 메시지 타입 정의

```typescript
// packages/types/src/ipc.ts

// 메시지 유형 열거형
export enum IpcMessageType {
  Connect = "Connect",
  Disconnect = "Disconnect",
  Ack = "Ack",
  TaskCommand = "TaskCommand",
  TaskEvent = "TaskEvent",
}

// 메시지 출처
export enum IpcOrigin {
  Client = "client",
  Server = "server",
}

// 작업 명령어
export enum TaskCommandName {
  StartNewTask = "StartNewTask",
  CancelTask = "CancelTask",
  CloseTask = "CloseTask",
  ResumeTask = "ResumeTask",
  SendMessage = "SendMessage",
}

// Discriminated Union으로 타입 안전한 메시지 정의
export const ipcMessageSchema = z.discriminatedUnion("type", [
  // 연결 확인
  z.object({
    type: z.literal(IpcMessageType.Ack),
    origin: z.literal(IpcOrigin.Server),
    data: ackSchema,
  }),

  // 클라이언트 명령
  z.object({
    type: z.literal(IpcMessageType.TaskCommand),
    origin: z.literal(IpcOrigin.Client),
    clientId: z.string(),
    data: taskCommandSchema,
  }),

  // 서버 이벤트
  z.object({
    type: z.literal(IpcMessageType.TaskEvent),
    origin: z.literal(IpcOrigin.Server),
    relayClientId: z.string().optional(),
    data: taskEventSchema,
  }),
])

export type IpcMessage = z.infer<typeof ipcMessageSchema>
```

### IPC 서버 구현

```typescript
// packages/ipc/src/ipc-server.ts
import ipc from "node-ipc"

export class IpcServer extends EventEmitter<IpcServerEvents> {
  private readonly _socketPath: string
  private readonly _clients: Map<string, Socket>
  private _isListening = false

  constructor(socketPath: string, log = console.log) {
    super()
    this._socketPath = socketPath
    this._clients = new Map()
  }

  public listen() {
    this._isListening = true
    ipc.config.silent = true

    ipc.serve(this.socketPath, () => {
      ipc.server.on("connect", (socket) => this.onConnect(socket))
      ipc.server.on("socket.disconnected", (socket) => this.onDisconnect(socket))
      ipc.server.on("message", (data) => this.onMessage(data))
    })

    ipc.server.start()
  }

  private onConnect(socket: Socket) {
    // 클라이언트 ID 생성 및 등록
    const clientId = crypto.randomBytes(6).toString("hex")
    this._clients.set(clientId, socket)

    // 연결 확인 메시지 전송
    this.send(socket, {
      type: IpcMessageType.Ack,
      origin: IpcOrigin.Server,
      data: { clientId, pid: process.pid, ppid: process.ppid },
    })

    this.emit(IpcMessageType.Connect, clientId)
  }

  private onMessage(data: unknown) {
    // Zod 스키마로 메시지 검증
    const result = ipcMessageSchema.safeParse(data)
    if (!result.success) {
      this.log(`Invalid payload: ${JSON.stringify(result.error.issues)}`)
      return
    }

    const payload = result.data

    // 클라이언트 명령 처리
    if (payload.origin === IpcOrigin.Client) {
      switch (payload.type) {
        case IpcMessageType.TaskCommand:
          this.emit(IpcMessageType.TaskCommand, payload.clientId, payload.data)
          break
      }
    }
  }

  // 특정 클라이언트에 메시지 전송
  public send(client: string | Socket, message: IpcMessage) {
    if (typeof client === "string") {
      const socket = this._clients.get(client)
      if (socket) {
        ipc.server.emit(socket, "message", message)
      }
    } else {
      ipc.server.emit(client, "message", message)
    }
  }

  // 모든 클라이언트에 브로드캐스트
  public broadcast(message: IpcMessage) {
    ipc.server.broadcast("message", message)
  }
}
```

### IPC 클라이언트 구현

```typescript
// packages/ipc/src/ipc-client.ts
import ipc from "node-ipc"

export class IpcClient extends EventEmitter<IpcClientEvents> {
  private _clientId?: string
  private _pid?: number

  constructor(
    private readonly socketPath: string,
    private readonly _log: (...args: unknown[]) => void = console.log,
  ) {
    super()
  }

  public connect() {
    ipc.config.silent = true

    ipc.connectTo("server", this.socketPath, () => {
      ipc.of.server.on("connect", () => this.onConnect())
      ipc.of.server.on("disconnect", () => this.onDisconnect())
      ipc.of.server.on("message", (data) => this.onMessage(data))
    })
  }

  private onMessage(data: unknown) {
    const result = ipcMessageSchema.safeParse(data)
    if (!result.success) return

    const payload = result.data

    if (payload.origin === IpcOrigin.Server) {
      switch (payload.type) {
        case IpcMessageType.Ack:
          this._clientId = payload.data.clientId
          this._pid = payload.data.pid
          this.emit(IpcMessageType.Ack, payload.data)
          break

        case IpcMessageType.TaskEvent:
          this.emit(IpcMessageType.TaskEvent, payload.data)
          break
      }
    }
  }

  // 작업 명령 전송
  public sendCommand(command: TaskCommand) {
    if (!this._clientId) return

    ipc.of.server.emit("message", {
      type: IpcMessageType.TaskCommand,
      origin: IpcOrigin.Client,
      clientId: this._clientId,
      data: command,
    })
  }

  // 메시지 전송 편의 메서드
  public sendTaskMessage(text?: string, images?: string[]) {
    this.sendCommand({
      commandName: TaskCommandName.SendMessage,
      data: { text, images },
    })
  }
}
```

### IPC 통신 시퀀스

```
┌─────────────┐                           ┌─────────────┐
│  IpcClient  │                           │  IpcServer  │
└──────┬──────┘                           └──────┬──────┘
       │                                         │
       │    connect()                            │
       │────────────────────────────────────────►│
       │                                         │
       │    Ack { clientId, pid }                │
       │◄────────────────────────────────────────│
       │                                         │
       │    TaskCommand { StartNewTask }         │
       │────────────────────────────────────────►│
       │                                         │
       │    TaskEvent { TaskStarted }            │
       │◄────────────────────────────────────────│
       │                                         │
       │    TaskEvent { Message }                │
       │◄────────────────────────────────────────│
       │                                         │
       │    TaskCommand { SendMessage }          │
       │────────────────────────────────────────►│
       │                                         │
       │    TaskEvent { TaskCompleted }          │
       │◄────────────────────────────────────────│
       │                                         │
```

---

## MessageManager 아키텍처

### 중앙화된 메시지 관리

```typescript
// src/core/message-manager/index.ts

export interface RewindOptions {
  includeTargetMessage?: boolean  // 대상 메시지 포함 삭제 여부
  skipCleanup?: boolean           // 정리 작업 건너뛰기
}

interface ContextEventIds {
  condenseIds: Set<string>       // 압축 이벤트 ID
  truncationIds: Set<string>     // 잘라내기 이벤트 ID
}

export class MessageManager {
  constructor(private task: Task) {}

  /**
   * 타임스탬프 기준으로 대화 되감기
   * 모든 메시지 삭제 작업의 단일 진입점
   */
  async rewindToTimestamp(ts: number, options: RewindOptions = {}): Promise<void> {
    const { includeTargetMessage = false, skipCleanup = false } = options

    // clineMessages에서 인덱스 찾기
    const clineIndex = this.task.clineMessages.findIndex((m) => m.ts === ts)
    if (clineIndex === -1) {
      throw new Error(`Message with timestamp ${ts} not found`)
    }

    // 실제 잘라낼 인덱스 계산
    const cutoffIndex = includeTargetMessage ? clineIndex + 1 : clineIndex

    await this.performRewind(cutoffIndex, ts, { skipCleanup })
  }

  /**
   * 인덱스 기준으로 대화 되감기
   * [0, toIndex) 유지, [toIndex, end] 삭제
   */
  async rewindToIndex(toIndex: number, options: RewindOptions = {}): Promise<void> {
    const cutoffTs = this.task.clineMessages[toIndex]?.ts ?? Date.now()
    await this.performRewind(toIndex, cutoffTs, options)
  }

  /**
   * 실제 되감기 수행
   */
  private async performRewind(toIndex: number, cutoffTs: number, options: RewindOptions): Promise<void> {
    const { skipCleanup = false } = options

    // 1단계: 제거될 메시지에서 컨텍스트 이벤트 ID 수집
    const removedIds = this.collectRemovedContextEventIds(toIndex)

    // 2단계: clineMessages 잘라내기
    await this.truncateClineMessages(toIndex)

    // 3단계: API 히스토리 잘라내기 및 정리
    await this.truncateApiHistoryWithCleanup(cutoffTs, removedIds, skipCleanup)
  }

  /**
   * 제거될 메시지에서 condense/truncation ID 수집
   * condense_context ↔ Summary, sliding_window_truncation ↔ Truncation marker
   * 간의 연결 유지를 위해 필수
   */
  private collectRemovedContextEventIds(fromIndex: number): ContextEventIds {
    const condenseIds = new Set<string>()
    const truncationIds = new Set<string>()

    for (let i = fromIndex; i < this.task.clineMessages.length; i++) {
      const msg = this.task.clineMessages[i]

      // condense_context 이벤트에서 condenseId 수집
      if (msg.say === "condense_context" && msg.contextCondense?.condenseId) {
        condenseIds.add(msg.contextCondense.condenseId)
      }

      // sliding_window_truncation 이벤트에서 truncationId 수집
      if (msg.say === "sliding_window_truncation" && msg.contextTruncation?.truncationId) {
        truncationIds.add(msg.contextTruncation.truncationId)
      }
    }

    return { condenseIds, truncationIds }
  }

  /**
   * API 히스토리 잘라내기 + 고아 메시지 정리
   * 단일 쓰기 작업으로 원자성 보장
   */
  private async truncateApiHistoryWithCleanup(
    cutoffTs: number,
    removedIds: ContextEventIds,
    skipCleanup: boolean,
  ): Promise<void> {
    const originalHistory = this.task.apiConversationHistory
    let apiHistory = [...originalHistory]

    // 1단계: 타임스탬프로 필터링
    apiHistory = apiHistory.filter((m) => !m.ts || m.ts < cutoffTs)

    // 2단계: 고아 Summary 제거 (condense_context가 삭제된 경우)
    if (removedIds.condenseIds.size > 0) {
      apiHistory = apiHistory.filter((msg) => {
        if (msg.isSummary && msg.condenseId && removedIds.condenseIds.has(msg.condenseId)) {
          console.log(`Removing orphaned Summary: ${msg.condenseId}`)
          return false
        }
        return true
      })
    }

    // 3단계: 고아 truncation marker 제거
    if (removedIds.truncationIds.size > 0) {
      apiHistory = apiHistory.filter((msg) => {
        if (msg.isTruncationMarker && msg.truncationId && removedIds.truncationIds.has(msg.truncationId)) {
          console.log(`Removing orphaned truncation marker: ${msg.truncationId}`)
          return false
        }
        return true
      })
    }

    // 4단계: 정리 (선택적)
    if (!skipCleanup) {
      apiHistory = cleanupAfterTruncation(apiHistory)
    }

    // 변경이 있을 때만 쓰기
    const historyChanged =
      apiHistory.length !== originalHistory.length ||
      apiHistory.some((msg, i) => msg !== originalHistory[i])

    if (historyChanged) {
      await this.task.overwriteApiConversationHistory(apiHistory)
    }
  }
}
```

### 히스토리 동기화 다이어그램

```
┌─────────────────────────────────────────────────────────────────────┐
│                    MessageManager 되감기 프로세스                     │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   Before Rewind:                                                    │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ clineMessages:                                              │  │
│   │ [msg1, msg2, condense_context{id:A}, msg3, msg4, TARGET]   │  │
│   └─────────────────────────────────────────────────────────────┘  │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ apiHistory:                                                 │  │
│   │ [api1, Summary{condenseId:A}, api2, api3, api4]            │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                     │
│   After Rewind (to msg2):                                           │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ clineMessages:                                              │  │
│   │ [msg1, msg2]  ← condense_context 삭제됨                     │  │
│   └─────────────────────────────────────────────────────────────┘  │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ apiHistory:                                                 │  │
│   │ [api1]  ← Summary{id:A}도 같이 삭제 (고아 방지)             │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 이벤트 시스템

### Task 이벤트

```typescript
// packages/types/src/task.ts

// Task 이벤트 유형
export type TaskEvents = {
  // 생명주기
  [RooCodeEventName.TaskStarted]: []
  [RooCodeEventName.TaskCompleted]: [taskId: string, tokenUsage: TokenUsage, toolUsage: ToolUsage]
  [RooCodeEventName.TaskAborted]: []
  [RooCodeEventName.TaskFocused]: []
  [RooCodeEventName.TaskUnfocused]: []

  // 상태 변경
  [RooCodeEventName.TaskActive]: [taskId: string]
  [RooCodeEventName.TaskInteractive]: [taskId: string]
  [RooCodeEventName.TaskResumable]: [taskId: string]
  [RooCodeEventName.TaskIdle]: [taskId: string]

  // 서브태스크
  [RooCodeEventName.TaskPaused]: [taskId: string]
  [RooCodeEventName.TaskUnpaused]: [taskId: string]
  [RooCodeEventName.TaskSpawned]: [taskId: string]

  // 실행
  [RooCodeEventName.Message]: [{ action: "created" | "updated"; message: ClineMessage }]
  [RooCodeEventName.TaskModeSwitched]: [taskId: string, mode: string]
  [RooCodeEventName.TaskAskResponded]: []
  [RooCodeEventName.TaskUserMessage]: [taskId: string]

  // 분석
  [RooCodeEventName.TaskToolFailed]: [taskId: string, tool: ToolName, error: string]
  [RooCodeEventName.TaskTokenUsageUpdated]: [taskId: string, tokenUsage: TokenUsage, toolUsage: ToolUsage]
}
```

### Provider 이벤트 전파

```typescript
// src/core/webview/ClineProvider.ts

export class ClineProvider extends EventEmitter<TaskProviderEvents> {
  private taskCreationCallback = (instance: Task) => {
    // Task 이벤트를 Provider 레벨로 전파
    this.emit(RooCodeEventName.TaskCreated, instance)

    // 개별 이벤트 리스너 등록
    const onTaskStarted = () => this.emit(RooCodeEventName.TaskStarted, instance.taskId)
    const onTaskCompleted = (taskId, tokenUsage, toolUsage) =>
      this.emit(RooCodeEventName.TaskCompleted, taskId, tokenUsage, toolUsage)
    const onTaskAborted = async () => {
      this.emit(RooCodeEventName.TaskAborted, instance.taskId)

      // 스트리밍 실패 시 자동 재hydrate
      if (instance.abortReason === "streaming_failed") {
        const { historyItem } = await this.getTaskWithId(instance.taskId)
        await this.createTaskWithHistoryItem(historyItem)
      }
    }

    // 이벤트 연결
    instance.on(RooCodeEventName.TaskStarted, onTaskStarted)
    instance.on(RooCodeEventName.TaskCompleted, onTaskCompleted)
    instance.on(RooCodeEventName.TaskAborted, onTaskAborted)
    // ... 추가 이벤트
  }
}
```

### 이벤트 흐름 다이어그램

```
┌─────────────────────────────────────────────────────────────────────┐
│                        이벤트 전파 흐름                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   Task                  ClineProvider              IpcServer        │
│    │                         │                         │            │
│    │ emit(TaskStarted)       │                         │            │
│    │────────────────────────►│                         │            │
│    │                         │ emit(TaskStarted)       │            │
│    │                         │────────────────────────►│            │
│    │                         │                         │ broadcast  │
│    │                         │                         │───────────►│
│    │                         │                         │ to clients │
│    │                         │                         │            │
│    │ emit(Message)           │                         │            │
│    │────────────────────────►│                         │            │
│    │                         │ postStateToWebview()    │            │
│    │                         │────────────────────────►│ WebView    │
│    │                         │                         │            │
│    │ emit(TaskCompleted)     │                         │            │
│    │────────────────────────►│                         │            │
│    │                         │ emit(TaskCompleted)     │            │
│    │                         │────────────────────────►│            │
│    │                         │                         │ broadcast  │
│    │                         │                         │───────────►│
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## Jupyter 커널 메시지 프로토콜 매핑

### 메시지 타입 매핑

| Roo-Code | Jupyter | 설명 |
|----------|---------|------|
| ClineMessage.ask | execute_request | 사용자 입력 요청 |
| ClineMessage.say | stream/execute_result | 출력 스트리밍 |
| api_req_started | execute_request | 실행 시작 |
| api_req_finished | execute_reply | 실행 완료 |
| command_output | stream (stdout/stderr) | 명령 출력 |
| error | error | 오류 메시지 |
| WebviewMessage | comm_msg | 프론트엔드 통신 |
| IpcMessage | shell/control 채널 | 외부 통신 |

### Jupyter 통합 아키텍처

```
┌─────────────────────────────────────────────────────────────────────┐
│                     Jupyter 메시지 통합                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   Roo-Code                          Jupyter                         │
│   ┌─────────────────┐              ┌─────────────────┐             │
│   │ ClineMessage    │              │ IOPub 채널       │             │
│   │ - ask/say       │ ◄──────────► │ - stream        │             │
│   │ - text          │              │ - execute_result│             │
│   │ - partial       │              │ - display_data  │             │
│   └─────────────────┘              └─────────────────┘             │
│                                                                     │
│   ┌─────────────────┐              ┌─────────────────┐             │
│   │ WebviewMessage  │              │ Shell 채널       │             │
│   │ - askResponse   │ ◄──────────► │ - execute_request│            │
│   │ - newTask       │              │ - execute_reply │             │
│   └─────────────────┘              └─────────────────┘             │
│                                                                     │
│   ┌─────────────────┐              ┌─────────────────┐             │
│   │ IpcMessage      │              │ Control 채널     │             │
│   │ - TaskCommand   │ ◄──────────► │ - interrupt     │             │
│   │ - TaskEvent     │              │ - shutdown      │             │
│   └─────────────────┘              └─────────────────┘             │
│                                                                     │
│   ┌─────────────────┐              ┌─────────────────┐             │
│   │ ExtensionState  │              │ Comm 채널        │             │
│   │ - clineMessages │ ◄──────────► │ - widget state  │             │
│   │ - settings      │              │ - custom msgs   │             │
│   └─────────────────┘              └─────────────────┘             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 구현 가이드

### Python 메시지 시스템 구현

```python
# hdsp_agent/messages/types.py
from enum import Enum
from typing import Optional, List, Dict, Any, Union
from dataclasses import dataclass, field
from datetime import datetime
import uuid


class AgentAskType(str, Enum):
    """사용자 응답 요청 유형"""
    FOLLOWUP = "followup"
    COMMAND = "command"
    COMMAND_OUTPUT = "command_output"
    COMPLETION_RESULT = "completion_result"
    TOOL = "tool"
    API_REQ_FAILED = "api_req_failed"
    RESUME_TASK = "resume_task"


class AgentSayType(str, Enum):
    """정보성 메시지 유형"""
    ERROR = "error"
    TEXT = "text"
    REASONING = "reasoning"
    API_REQ_STARTED = "api_req_started"
    API_REQ_FINISHED = "api_req_finished"
    COMMAND_OUTPUT = "command_output"
    COMPLETION_RESULT = "completion_result"
    CELL_EXECUTED = "cell_executed"  # Jupyter 전용
    KERNEL_STATUS = "kernel_status"  # Jupyter 전용


@dataclass
class AgentMessage:
    """AI 에이전트 대화 메시지"""
    ts: float = field(default_factory=lambda: datetime.now().timestamp())
    type: str = "say"  # "ask" or "say"
    ask: Optional[AgentAskType] = None
    say: Optional[AgentSayType] = None
    text: Optional[str] = None
    images: List[str] = field(default_factory=list)
    partial: bool = False
    reasoning: Optional[str] = None
    metadata: Dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "ts": self.ts,
            "type": self.type,
            "ask": self.ask.value if self.ask else None,
            "say": self.say.value if self.say else None,
            "text": self.text,
            "images": self.images,
            "partial": self.partial,
            "reasoning": self.reasoning,
            "metadata": self.metadata,
        }

    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> "AgentMessage":
        return cls(
            ts=data.get("ts", datetime.now().timestamp()),
            type=data.get("type", "say"),
            ask=AgentAskType(data["ask"]) if data.get("ask") else None,
            say=AgentSayType(data["say"]) if data.get("say") else None,
            text=data.get("text"),
            images=data.get("images", []),
            partial=data.get("partial", False),
            reasoning=data.get("reasoning"),
            metadata=data.get("metadata", {}),
        )


# Ask 타입 분류
IDLE_ASKS = {AgentAskType.COMPLETION_RESULT, AgentAskType.API_REQ_FAILED}
RESUMABLE_ASKS = {AgentAskType.RESUME_TASK}
INTERACTIVE_ASKS = {AgentAskType.FOLLOWUP, AgentAskType.COMMAND, AgentAskType.TOOL}
NON_BLOCKING_ASKS = {AgentAskType.COMMAND_OUTPUT}


def is_idle_ask(ask: AgentAskType) -> bool:
    return ask in IDLE_ASKS


def is_interactive_ask(ask: AgentAskType) -> bool:
    return ask in INTERACTIVE_ASKS
```

### Python 메시지 관리자

```python
# hdsp_agent/messages/manager.py
from typing import List, Optional, Set, Dict, Any
from dataclasses import dataclass
import asyncio

from .types import AgentMessage, AgentSayType


@dataclass
class RewindOptions:
    """되감기 옵션"""
    include_target_message: bool = False
    skip_cleanup: bool = False


@dataclass
class ContextEventIds:
    """컨텍스트 이벤트 ID"""
    condense_ids: Set[str]
    truncation_ids: Set[str]


class MessageManager:
    """중앙화된 메시지 관리자"""

    def __init__(self, task: "Task"):
        self.task = task

    async def rewind_to_timestamp(
        self,
        ts: float,
        options: Optional[RewindOptions] = None
    ) -> None:
        """타임스탬프 기준 되감기"""
        options = options or RewindOptions()

        # 인덱스 찾기
        cline_index = next(
            (i for i, m in enumerate(self.task.messages) if m.ts == ts),
            -1
        )
        if cline_index == -1:
            raise ValueError(f"Message with timestamp {ts} not found")

        cutoff_index = cline_index + 1 if options.include_target_message else cline_index
        await self._perform_rewind(cutoff_index, ts, options)

    async def rewind_to_index(
        self,
        to_index: int,
        options: Optional[RewindOptions] = None
    ) -> None:
        """인덱스 기준 되감기"""
        options = options or RewindOptions()
        cutoff_ts = (
            self.task.messages[to_index].ts
            if to_index < len(self.task.messages)
            else asyncio.get_event_loop().time()
        )
        await self._perform_rewind(to_index, cutoff_ts, options)

    async def _perform_rewind(
        self,
        to_index: int,
        cutoff_ts: float,
        options: RewindOptions
    ) -> None:
        """실제 되감기 수행"""
        # 1단계: 제거될 컨텍스트 이벤트 ID 수집
        removed_ids = self._collect_removed_context_ids(to_index)

        # 2단계: UI 메시지 잘라내기
        await self._truncate_messages(to_index)

        # 3단계: API 히스토리 정리
        await self._truncate_api_history(cutoff_ts, removed_ids, options.skip_cleanup)

    def _collect_removed_context_ids(self, from_index: int) -> ContextEventIds:
        """제거될 메시지의 컨텍스트 ID 수집"""
        condense_ids: Set[str] = set()
        truncation_ids: Set[str] = set()

        for i in range(from_index, len(self.task.messages)):
            msg = self.task.messages[i]

            if msg.say == AgentSayType.CONDENSE_CONTEXT:
                condense_id = msg.metadata.get("condense_id")
                if condense_id:
                    condense_ids.add(condense_id)

            if msg.say == AgentSayType.SLIDING_WINDOW_TRUNCATION:
                truncation_id = msg.metadata.get("truncation_id")
                if truncation_id:
                    truncation_ids.add(truncation_id)

        return ContextEventIds(condense_ids, truncation_ids)

    async def _truncate_messages(self, to_index: int) -> None:
        """메시지 잘라내기"""
        self.task.messages = self.task.messages[:to_index]
        await self.task.save_messages()

    async def _truncate_api_history(
        self,
        cutoff_ts: float,
        removed_ids: ContextEventIds,
        skip_cleanup: bool
    ) -> None:
        """API 히스토리 잘라내기 및 정리"""
        history = self.task.api_history.copy()

        # 타임스탬프로 필터
        history = [m for m in history if not m.get("ts") or m["ts"] < cutoff_ts]

        # 고아 Summary 제거
        if removed_ids.condense_ids:
            history = [
                m for m in history
                if not (
                    m.get("is_summary") and
                    m.get("condense_id") in removed_ids.condense_ids
                )
            ]

        # 고아 truncation marker 제거
        if removed_ids.truncation_ids:
            history = [
                m for m in history
                if not (
                    m.get("is_truncation_marker") and
                    m.get("truncation_id") in removed_ids.truncation_ids
                )
            ]

        self.task.api_history = history
        await self.task.save_api_history()
```

### Python WebSocket 통신

```python
# hdsp_agent/comm/websocket.py
import asyncio
import json
from typing import Dict, Any, Optional, Callable, Awaitable
from dataclasses import dataclass, asdict
from enum import Enum
import websockets
from websockets.server import WebSocketServerProtocol


class MessageType(str, Enum):
    """메시지 유형"""
    STATE = "state"
    ACTION = "action"
    INVOKE = "invoke"
    MESSAGE_UPDATED = "messageUpdated"
    ASK_RESPONSE = "askResponse"
    NEW_TASK = "newTask"
    CANCEL_TASK = "cancelTask"


@dataclass
class ExtensionMessage:
    """Extension에서 WebView로 보내는 메시지"""
    type: MessageType
    state: Optional[Dict[str, Any]] = None
    action: Optional[str] = None
    invoke: Optional[str] = None
    message: Optional[Dict[str, Any]] = None

    def to_json(self) -> str:
        data = {k: v for k, v in asdict(self).items() if v is not None}
        data["type"] = self.type.value
        return json.dumps(data)


@dataclass
class WebviewMessage:
    """WebView에서 Extension으로 보내는 메시지"""
    type: str
    text: Optional[str] = None
    ask_response: Optional[str] = None
    images: Optional[list] = None
    message_ts: Optional[float] = None

    @classmethod
    def from_json(cls, data: str) -> "WebviewMessage":
        parsed = json.loads(data)
        return cls(
            type=parsed.get("type", ""),
            text=parsed.get("text"),
            ask_response=parsed.get("askResponse"),
            images=parsed.get("images"),
            message_ts=parsed.get("messageTs"),
        )


class WebSocketServer:
    """WebSocket 통신 서버"""

    def __init__(self, host: str = "localhost", port: int = 8765):
        self.host = host
        self.port = port
        self.clients: set[WebSocketServerProtocol] = set()
        self.handlers: Dict[str, Callable[[WebviewMessage], Awaitable[None]]] = {}

    def register_handler(
        self,
        message_type: str,
        handler: Callable[[WebviewMessage], Awaitable[None]]
    ) -> None:
        """메시지 핸들러 등록"""
        self.handlers[message_type] = handler

    async def start(self) -> None:
        """서버 시작"""
        async with websockets.serve(self._handle_client, self.host, self.port):
            await asyncio.Future()  # 무한 대기

    async def _handle_client(self, websocket: WebSocketServerProtocol) -> None:
        """클라이언트 연결 처리"""
        self.clients.add(websocket)
        try:
            async for raw_message in websocket:
                await self._process_message(raw_message)
        finally:
            self.clients.discard(websocket)

    async def _process_message(self, raw_message: str) -> None:
        """메시지 처리"""
        try:
            message = WebviewMessage.from_json(raw_message)
            handler = self.handlers.get(message.type)
            if handler:
                await handler(message)
        except Exception as e:
            print(f"Error processing message: {e}")

    async def broadcast(self, message: ExtensionMessage) -> None:
        """모든 클라이언트에 브로드캐스트"""
        if self.clients:
            await asyncio.gather(
                *[client.send(message.to_json()) for client in self.clients]
            )

    async def send_state(self, state: Dict[str, Any]) -> None:
        """상태 업데이트 전송"""
        await self.broadcast(ExtensionMessage(
            type=MessageType.STATE,
            state=state
        ))
```

### Jupyter 커널 메시지 브릿지

```python
# hdsp_agent/comm/jupyter_bridge.py
from typing import Dict, Any, Optional, Callable
import asyncio
from jupyter_client import AsyncKernelClient
from jupyter_client.channels import ZMQSocketChannel

from .websocket import WebSocketServer, ExtensionMessage, MessageType
from ..messages.types import AgentMessage, AgentSayType


class JupyterMessageBridge:
    """Jupyter 커널 메시지와 에이전트 메시지 간 브릿지"""

    def __init__(
        self,
        kernel_client: AsyncKernelClient,
        websocket_server: WebSocketServer
    ):
        self.kernel_client = kernel_client
        self.websocket_server = websocket_server
        self._message_handlers: Dict[str, Callable] = {}

    async def start(self) -> None:
        """메시지 브릿지 시작"""
        # IOPub 채널 메시지 수신
        asyncio.create_task(self._process_iopub_messages())

    async def _process_iopub_messages(self) -> None:
        """IOPub 채널 메시지 처리"""
        while True:
            try:
                msg = await self.kernel_client.get_iopub_msg(timeout=1.0)
                await self._handle_kernel_message(msg)
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                print(f"Error processing IOPub message: {e}")

    async def _handle_kernel_message(self, msg: Dict[str, Any]) -> None:
        """커널 메시지를 에이전트 메시지로 변환"""
        msg_type = msg["header"]["msg_type"]
        content = msg["content"]

        agent_message: Optional[AgentMessage] = None

        if msg_type == "stream":
            # stdout/stderr 출력
            agent_message = AgentMessage(
                type="say",
                say=AgentSayType.COMMAND_OUTPUT,
                text=content.get("text", ""),
                metadata={"stream": content.get("name", "stdout")}
            )

        elif msg_type == "execute_result":
            # 실행 결과
            agent_message = AgentMessage(
                type="say",
                say=AgentSayType.CELL_EXECUTED,
                text=str(content.get("data", {}).get("text/plain", "")),
                metadata={
                    "execution_count": content.get("execution_count"),
                    "data": content.get("data", {}),
                }
            )

        elif msg_type == "error":
            # 오류
            agent_message = AgentMessage(
                type="say",
                say=AgentSayType.ERROR,
                text="\n".join(content.get("traceback", [])),
                metadata={
                    "ename": content.get("ename"),
                    "evalue": content.get("evalue"),
                }
            )

        elif msg_type == "status":
            # 커널 상태
            agent_message = AgentMessage(
                type="say",
                say=AgentSayType.KERNEL_STATUS,
                text=content.get("execution_state", ""),
            )

        elif msg_type == "display_data":
            # 디스플레이 데이터 (이미지 등)
            data = content.get("data", {})
            images = []

            if "image/png" in data:
                images.append(f"data:image/png;base64,{data['image/png']}")
            if "image/jpeg" in data:
                images.append(f"data:image/jpeg;base64,{data['image/jpeg']}")

            agent_message = AgentMessage(
                type="say",
                say=AgentSayType.TEXT,
                text=data.get("text/plain", ""),
                images=images,
            )

        if agent_message:
            # WebSocket으로 브로드캐스트
            await self.websocket_server.broadcast(
                ExtensionMessage(
                    type=MessageType.MESSAGE_UPDATED,
                    message=agent_message.to_dict()
                )
            )

    async def execute_code(self, code: str) -> str:
        """코드 실행 및 메시지 ID 반환"""
        msg_id = self.kernel_client.execute(code)
        return msg_id

    async def interrupt_kernel(self) -> None:
        """커널 인터럽트"""
        self.kernel_client.interrupt()

    async def shutdown_kernel(self) -> None:
        """커널 종료"""
        self.kernel_client.shutdown()
```

### 이벤트 에미터

```python
# hdsp_agent/events/emitter.py
from typing import Dict, List, Callable, Any, TypeVar, Generic
from dataclasses import dataclass
import asyncio


T = TypeVar('T')


class EventEmitter(Generic[T]):
    """타입 안전한 이벤트 에미터"""

    def __init__(self):
        self._listeners: Dict[str, List[Callable[..., Any]]] = {}

    def on(self, event: str, callback: Callable[..., Any]) -> Callable[[], None]:
        """이벤트 리스너 등록"""
        if event not in self._listeners:
            self._listeners[event] = []
        self._listeners[event].append(callback)

        # 해제 함수 반환
        def remove():
            if callback in self._listeners.get(event, []):
                self._listeners[event].remove(callback)
        return remove

    def off(self, event: str, callback: Callable[..., Any]) -> None:
        """이벤트 리스너 제거"""
        if event in self._listeners and callback in self._listeners[event]:
            self._listeners[event].remove(callback)

    async def emit(self, event: str, *args: Any) -> None:
        """이벤트 발생 (비동기)"""
        if event in self._listeners:
            for callback in self._listeners[event]:
                result = callback(*args)
                if asyncio.iscoroutine(result):
                    await result

    def emit_sync(self, event: str, *args: Any) -> None:
        """이벤트 발생 (동기)"""
        if event in self._listeners:
            for callback in self._listeners[event]:
                callback(*args)


# 이벤트 이름 상수
class TaskEventName:
    TASK_STARTED = "task:started"
    TASK_COMPLETED = "task:completed"
    TASK_ABORTED = "task:aborted"
    TASK_ACTIVE = "task:active"
    TASK_INTERACTIVE = "task:interactive"
    TASK_IDLE = "task:idle"
    MESSAGE = "message"
    TOKEN_USAGE_UPDATED = "token_usage:updated"
```

### 통합 사용 예제

```python
# hdsp_agent/agent.py
from typing import Optional, List
import asyncio

from .messages.types import AgentMessage, AgentAskType, AgentSayType
from .messages.manager import MessageManager
from .comm.websocket import WebSocketServer, WebviewMessage
from .comm.jupyter_bridge import JupyterMessageBridge
from .events.emitter import EventEmitter, TaskEventName


class HDSPAgent(EventEmitter):
    """HDSP AI 에이전트 메인 클래스"""

    def __init__(self, kernel_client):
        super().__init__()
        self.messages: List[AgentMessage] = []
        self.api_history: List[dict] = []
        self.message_manager = MessageManager(self)

        # 통신 설정
        self.websocket_server = WebSocketServer()
        self.jupyter_bridge = JupyterMessageBridge(
            kernel_client,
            self.websocket_server
        )

        # 핸들러 등록
        self._setup_handlers()

    def _setup_handlers(self) -> None:
        """메시지 핸들러 설정"""
        self.websocket_server.register_handler("newTask", self._handle_new_task)
        self.websocket_server.register_handler("askResponse", self._handle_ask_response)
        self.websocket_server.register_handler("cancelTask", self._handle_cancel)
        self.websocket_server.register_handler("deleteMessage", self._handle_delete)

    async def start(self) -> None:
        """에이전트 시작"""
        # WebSocket 서버 시작
        asyncio.create_task(self.websocket_server.start())
        # Jupyter 브릿지 시작
        await self.jupyter_bridge.start()

    async def say(
        self,
        say_type: AgentSayType,
        text: Optional[str] = None,
        partial: bool = False,
        **kwargs
    ) -> None:
        """정보성 메시지 전송"""
        message = AgentMessage(
            type="say",
            say=say_type,
            text=text,
            partial=partial,
            **kwargs
        )

        if partial and self.messages:
            # 스트리밍: 마지막 메시지 업데이트
            last = self.messages[-1]
            if last.partial and last.say == say_type:
                last.text = text
                await self._notify_message_update(last)
                return

        self.messages.append(message)
        await self._notify_message_update(message)

    async def ask(
        self,
        ask_type: AgentAskType,
        text: Optional[str] = None,
        **kwargs
    ) -> str:
        """사용자 응답 요청"""
        message = AgentMessage(
            type="ask",
            ask=ask_type,
            text=text,
            **kwargs
        )
        self.messages.append(message)
        await self._notify_message_update(message)

        # 응답 대기
        response = await self._wait_for_response()
        return response

    async def _wait_for_response(self) -> str:
        """사용자 응답 대기"""
        future = asyncio.Future()

        def on_response(msg: WebviewMessage):
            if msg.ask_response:
                future.set_result(msg.text or "")

        self.websocket_server.register_handler("askResponse", on_response)

        try:
            return await future
        finally:
            # 핸들러 정리
            pass

    async def _notify_message_update(self, message: AgentMessage) -> None:
        """메시지 업데이트 알림"""
        await self.emit(TaskEventName.MESSAGE, {
            "action": "updated" if message.partial else "created",
            "message": message
        })

    async def _handle_new_task(self, msg: WebviewMessage) -> None:
        """새 작업 처리"""
        await self.emit(TaskEventName.TASK_STARTED)
        # 작업 시작 로직

    async def _handle_ask_response(self, msg: WebviewMessage) -> None:
        """응답 처리"""
        # 응답 처리 로직
        pass

    async def _handle_cancel(self, msg: WebviewMessage) -> None:
        """작업 취소"""
        await self.emit(TaskEventName.TASK_ABORTED)

    async def _handle_delete(self, msg: WebviewMessage) -> None:
        """메시지 삭제"""
        if msg.message_ts:
            await self.message_manager.rewind_to_timestamp(msg.message_ts)


# 사용 예제
async def main():
    from jupyter_client import AsyncKernelClient

    # 커널 클라이언트 설정
    kernel_client = AsyncKernelClient()
    kernel_client.load_connection_file("connection.json")
    kernel_client.start_channels()

    # 에이전트 생성 및 시작
    agent = HDSPAgent(kernel_client)
    await agent.start()

    # 이벤트 리스너 등록
    agent.on(TaskEventName.TASK_STARTED, lambda: print("Task started"))
    agent.on(TaskEventName.MESSAGE, lambda m: print(f"Message: {m}"))

    # 대화 시작
    await agent.say(AgentSayType.TEXT, "안녕하세요! 무엇을 도와드릴까요?")

    # 사용자 입력 대기
    response = await agent.ask(AgentAskType.FOLLOWUP, "어떤 작업을 수행할까요?")
    print(f"User response: {response}")


if __name__ == "__main__":
    asyncio.run(main())
```

---

## 핵심 패턴 요약

### 1. 타임스탬프 기반 식별

- 모든 메시지는 `ts` (timestamp)로 고유 식별
- 되감기/편집/삭제 작업의 기준점

### 2. Discriminated Union 패턴

- `ask`/`say` 타입으로 메시지 성격 구분
- 각 타입별 세부 열거형으로 타입 안전성 확보

### 3. 이중 히스토리 관리

- UI 히스토리: 사용자 경험 중심
- API 히스토리: AI 컨텍스트 중심
- 동기화 시 고아 메시지 방지

### 4. 이벤트 기반 통신

- Task → Provider → IPC 순으로 이벤트 전파
- 느슨한 결합으로 확장성 확보

### 5. Zod 스키마 검증

- 런타임 타입 안전성 보장
- 외부 메시지 검증

---

## 참고 자료

- Roo-Code 메시지 타입: `packages/types/src/message.ts`
- WebView 통신: `src/shared/ExtensionMessage.ts`, `src/shared/WebviewMessage.ts`
- IPC 구현: `packages/ipc/src/`
- MessageManager: `src/core/message-manager/index.ts`
- Jupyter Message Protocol: https://jupyter-client.readthedocs.io/en/stable/messaging.html
