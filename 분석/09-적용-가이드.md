# 09. hdsp-agent 적용 가이드

## 개요

이 문서는 Roo-Code 분석 결과를 바탕으로 **Jupyter 기반 AI 에이전트(hdsp-agent)**를 구현하기 위한 종합 가이드입니다. Roo-Code의 검증된 아키텍처 패턴을 Jupyter/Python 생태계에 맞게 변환하여 적용합니다.

## 1. 아키텍처 매핑

### 1.1 전체 컴포넌트 매핑

```
┌──────────────────────────────────────────────────────────────────────┐
│                    Roo-Code (VSCode)                                 │
│                           ↓                                          │
│                    hdsp-agent (Jupyter)                              │
└──────────────────────────────────────────────────────────────────────┘

┌────────────────────────┬────────────────────────┐
│     Roo-Code           │     hdsp-agent         │
├────────────────────────┼────────────────────────┤
│ vscode.ExtensionContext│ JupyterLab ServiceManager│
│ ClineProvider          │ AgentProvider          │
│ Task                   │ TaskManager            │
│ BaseTool               │ BaseTool               │
│ WebView                │ JupyterLab Panel       │
│ McpHub                 │ McpBridge              │
│ globalState/secrets    │ ConfigManager          │
│ ShadowCheckpointService│ NotebookCheckpoint     │
│ ContextProxy           │ StateProxy             │
│ MessageManager         │ MessageManager         │
│ ApiHandler             │ LLMProvider            │
└────────────────────────┴────────────────────────┘
```

### 1.2 핵심 아키텍처 원칙

1. **싱글톤 서비스 계층**: 전역 상태 관리를 위한 싱글톤 패턴
2. **이벤트 드리븐 통신**: 비동기 메시지 기반 컴포넌트 통신
3. **프로바이더 추상화**: 다중 LLM 프로바이더 지원
4. **플러그인 도구 시스템**: 확장 가능한 도구 아키텍처
5. **비파괴적 히스토리**: 마커 기반 히스토리 관리

## 2. 필수 구현 컴포넌트

### 2.1 컴포넌트 우선순위

```
Phase 1 (핵심 기반)
├── StateProxy          # 상태 관리
├── ConfigManager       # 설정 관리
├── LLMProvider         # LLM API 추상화
└── BaseTool           # 도구 기반 클래스

Phase 2 (에이전트 코어)
├── TaskManager         # 작업 오케스트레이션
├── MessageManager      # 메시지 관리
├── KernelBridge        # Jupyter 커널 통신
└── ToolExecutor        # 도구 실행 엔진

Phase 3 (사용자 경험)
├── PanelProvider       # UI 패널
├── NotebookCheckpoint  # 체크포인트
└── McpBridge          # MCP 통합

Phase 4 (고급 기능)
├── ContextCondenser    # 컨텍스트 압축
├── TelemetryService    # 텔레메트리
└── SessionPersistence  # 세션 지속성
```

### 2.2 최소 실행 가능 제품(MVP) 구성

```python
# MVP를 위한 최소 컴포넌트
hdsp_agent/
├── __init__.py
├── core/
│   ├── state.py         # StateProxy
│   ├── config.py        # ConfigManager
│   └── task.py          # TaskManager
├── providers/
│   ├── base.py          # BaseLLMProvider
│   ├── anthropic.py     # Claude 지원
│   └── openai.py        # OpenAI 지원
├── tools/
│   ├── base.py          # BaseTool
│   ├── execute_code.py  # 코드 실행
│   ├── read_file.py     # 파일 읽기
│   └── write_file.py    # 파일 쓰기
├── kernel/
│   └── bridge.py        # KernelBridge
└── messages/
    ├── types.py         # 메시지 타입
    └── manager.py       # MessageManager
```

## 3. 핵심 컴포넌트 구현

### 3.1 StateProxy (상태 관리)

```python
# hdsp_agent/core/state.py
from typing import TypeVar, Generic, Optional, Dict, Any
from pydantic import BaseModel, ValidationError
from pathlib import Path
import json
import keyring

T = TypeVar('T', bound=BaseModel)

class StateProxy(Generic[T]):
    """
    Roo-Code ContextProxy 패턴의 Python 구현.
    Pydantic 검증 + 메모리 캐싱 + 영속성.
    """
    _instance: Optional['StateProxy'] = None

    def __init__(
        self,
        state_class: type[T],
        state_path: Path,
        secret_namespace: str = "hdsp-agent"
    ):
        self._state_class = state_class
        self._state_path = state_path
        self._secret_namespace = secret_namespace
        self._cache: Optional[T] = None
        self._dirty = False

    @classmethod
    def get_instance(cls) -> 'StateProxy':
        if cls._instance is None:
            raise RuntimeError("StateProxy not initialized")
        return cls._instance

    @classmethod
    def initialize(
        cls,
        state_class: type[T],
        state_path: Path,
        **kwargs
    ) -> 'StateProxy[T]':
        cls._instance = cls(state_class, state_path, **kwargs)
        cls._instance.load()
        return cls._instance

    def load(self) -> T:
        """상태 로드 및 캐싱."""
        if self._cache is not None:
            return self._cache

        if self._state_path.exists():
            try:
                data = json.loads(self._state_path.read_text())
                self._cache = self._state_class.model_validate(data)
            except (json.JSONDecodeError, ValidationError) as e:
                # 마이그레이션 또는 기본값 사용
                self._cache = self._state_class()
        else:
            self._cache = self._state_class()

        return self._cache

    def get(self) -> T:
        """현재 상태 반환 (캐시)."""
        if self._cache is None:
            return self.load()
        return self._cache

    def update(self, **kwargs) -> T:
        """상태 업데이트 (검증 포함)."""
        current = self.get()
        updated_data = current.model_dump()
        updated_data.update(kwargs)

        # Pydantic 검증
        self._cache = self._state_class.model_validate(updated_data)
        self._dirty = True
        return self._cache

    def save(self) -> None:
        """상태 저장 (원자적)."""
        if not self._dirty or self._cache is None:
            return

        # 원자적 쓰기: 임시 파일 → 이름 변경
        temp_path = self._state_path.with_suffix('.tmp')
        temp_path.write_text(
            self._cache.model_dump_json(indent=2)
        )
        temp_path.rename(self._state_path)
        self._dirty = False

    # 시크릿 관리
    def get_secret(self, key: str) -> Optional[str]:
        """시크릿 조회."""
        return keyring.get_password(self._secret_namespace, key)

    def set_secret(self, key: str, value: str) -> None:
        """시크릿 저장."""
        keyring.set_password(self._secret_namespace, key, value)

    def delete_secret(self, key: str) -> None:
        """시크릿 삭제."""
        try:
            keyring.delete_password(self._secret_namespace, key)
        except keyring.errors.PasswordDeleteError:
            pass


# 상태 스키마 정의
class GlobalState(BaseModel):
    """전역 상태 스키마."""
    current_api_config: str = "default"
    custom_instructions: str = ""
    mode: str = "code"
    auto_approval_enabled: bool = False
    max_requests: int = 100
    language: str = "en"

    class Config:
        extra = "ignore"  # 알 수 없는 필드 무시 (마이그레이션 용이)
```

### 3.2 ConfigManager (설정 관리)

```python
# hdsp_agent/core/config.py
from typing import Dict, Any, Optional
from pydantic import BaseModel, Field
from pathlib import Path
import json
import yaml

class ProviderConfig(BaseModel):
    """LLM 프로바이더 설정."""
    name: str
    api_key_name: str  # keyring에서 조회할 키 이름
    base_url: Optional[str] = None
    model: str
    max_tokens: int = 4096
    temperature: float = 0.7

class ApiConfig(BaseModel):
    """API 설정 프로필."""
    name: str
    provider: str
    model: str
    custom_settings: Dict[str, Any] = Field(default_factory=dict)

class ConfigManager:
    """
    설정 관리자.
    - 여러 API 프로필 지원
    - 환경별 설정 (개발/프로덕션)
    - 설정 내보내기/가져오기
    """

    def __init__(self, config_dir: Path):
        self.config_dir = config_dir
        self.config_dir.mkdir(parents=True, exist_ok=True)

        self.providers_path = config_dir / "providers.yaml"
        self.profiles_path = config_dir / "profiles.json"

        self._providers: Dict[str, ProviderConfig] = {}
        self._profiles: Dict[str, ApiConfig] = {}
        self._load_configs()

    def _load_configs(self) -> None:
        """설정 로드."""
        # 프로바이더 설정 (YAML)
        if self.providers_path.exists():
            data = yaml.safe_load(self.providers_path.read_text())
            for name, config in data.get("providers", {}).items():
                self._providers[name] = ProviderConfig(name=name, **config)

        # API 프로필 (JSON)
        if self.profiles_path.exists():
            data = json.loads(self.profiles_path.read_text())
            for name, config in data.items():
                self._profiles[name] = ApiConfig(name=name, **config)

    def get_provider(self, name: str) -> Optional[ProviderConfig]:
        """프로바이더 설정 조회."""
        return self._providers.get(name)

    def get_profile(self, name: str) -> Optional[ApiConfig]:
        """API 프로필 조회."""
        return self._profiles.get(name)

    def list_profiles(self) -> list[str]:
        """프로필 목록."""
        return list(self._profiles.keys())

    def save_profile(self, profile: ApiConfig) -> None:
        """프로필 저장."""
        self._profiles[profile.name] = profile
        self._save_profiles()

    def _save_profiles(self) -> None:
        """프로필 파일 저장."""
        data = {
            name: profile.model_dump(exclude={"name"})
            for name, profile in self._profiles.items()
        }
        self.profiles_path.write_text(json.dumps(data, indent=2))

    def export_settings(self, path: Path) -> None:
        """설정 내보내기 (시크릿 제외)."""
        export_data = {
            "providers": {
                name: config.model_dump(exclude={"api_key_name"})
                for name, config in self._providers.items()
            },
            "profiles": {
                name: config.model_dump()
                for name, config in self._profiles.items()
            }
        }
        path.write_text(json.dumps(export_data, indent=2))

    def import_settings(self, path: Path) -> None:
        """설정 가져오기."""
        data = json.loads(path.read_text())

        for name, config in data.get("profiles", {}).items():
            self._profiles[name] = ApiConfig(name=name, **config)

        self._save_profiles()
```

### 3.3 LLM Provider (LLM 추상화)

```python
# hdsp_agent/providers/base.py
from abc import ABC, abstractmethod
from typing import AsyncIterator, Optional, List, Dict, Any
from pydantic import BaseModel
from enum import Enum
import asyncio

class MessageRole(str, Enum):
    USER = "user"
    ASSISTANT = "assistant"
    SYSTEM = "system"

class ContentBlock(BaseModel):
    """콘텐츠 블록 (텍스트, 이미지, 도구 사용 등)."""
    type: str
    text: Optional[str] = None
    tool_use_id: Optional[str] = None
    tool_name: Optional[str] = None
    tool_input: Optional[Dict[str, Any]] = None
    image_data: Optional[str] = None

class Message(BaseModel):
    """대화 메시지."""
    role: MessageRole
    content: List[ContentBlock]

class StreamChunk(BaseModel):
    """스트리밍 청크."""
    type: str  # "text", "tool_use", "usage", "done"
    text: Optional[str] = None
    tool_use_id: Optional[str] = None
    tool_name: Optional[str] = None
    tool_input: Optional[Dict[str, Any]] = None
    input_tokens: Optional[int] = None
    output_tokens: Optional[int] = None

class BaseLLMProvider(ABC):
    """
    LLM 프로바이더 추상 기반 클래스.
    Roo-Code의 ApiHandler 패턴 적용.
    """

    def __init__(self, api_key: str, model: str, **kwargs):
        self.api_key = api_key
        self.model = model
        self.options = kwargs

    @abstractmethod
    async def create_message(
        self,
        system_prompt: str,
        messages: List[Message],
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> AsyncIterator[StreamChunk]:
        """
        메시지 생성 (스트리밍).

        Yields:
            StreamChunk: 스트리밍 청크
        """
        pass

    @abstractmethod
    def get_model_info(self) -> Dict[str, Any]:
        """모델 정보 반환."""
        pass

    def count_tokens(self, text: str) -> int:
        """토큰 수 계산 (기본 추정)."""
        # 기본: 문자 수 / 4 (대략적 추정)
        return len(text) // 4


# hdsp_agent/providers/anthropic.py
from anthropic import AsyncAnthropic
from .base import BaseLLMProvider, StreamChunk, Message, ContentBlock

class AnthropicProvider(BaseLLMProvider):
    """Anthropic Claude 프로바이더."""

    def __init__(self, api_key: str, model: str = "claude-sonnet-4-20250514", **kwargs):
        super().__init__(api_key, model, **kwargs)
        self.client = AsyncAnthropic(api_key=api_key)

    async def create_message(
        self,
        system_prompt: str,
        messages: List[Message],
        tools: Optional[List[Dict[str, Any]]] = None,
        **kwargs
    ) -> AsyncIterator[StreamChunk]:
        """Claude API 스트리밍 호출."""

        # 메시지 변환
        api_messages = []
        for msg in messages:
            content = []
            for block in msg.content:
                if block.type == "text":
                    content.append({"type": "text", "text": block.text})
                elif block.type == "tool_result":
                    content.append({
                        "type": "tool_result",
                        "tool_use_id": block.tool_use_id,
                        "content": block.text
                    })
            api_messages.append({
                "role": msg.role.value,
                "content": content
            })

        # API 호출
        params = {
            "model": self.model,
            "max_tokens": kwargs.get("max_tokens", 4096),
            "system": system_prompt,
            "messages": api_messages,
        }

        if tools:
            params["tools"] = tools

        async with self.client.messages.stream(**params) as stream:
            async for event in stream:
                if event.type == "content_block_delta":
                    if hasattr(event.delta, "text"):
                        yield StreamChunk(
                            type="text",
                            text=event.delta.text
                        )
                    elif hasattr(event.delta, "partial_json"):
                        yield StreamChunk(
                            type="tool_input_delta",
                            text=event.delta.partial_json
                        )

                elif event.type == "content_block_start":
                    if event.content_block.type == "tool_use":
                        yield StreamChunk(
                            type="tool_use",
                            tool_use_id=event.content_block.id,
                            tool_name=event.content_block.name
                        )

                elif event.type == "message_delta":
                    if hasattr(event.usage, "output_tokens"):
                        yield StreamChunk(
                            type="usage",
                            output_tokens=event.usage.output_tokens
                        )

            # 최종 메시지 정보
            final_message = await stream.get_final_message()
            yield StreamChunk(
                type="done",
                input_tokens=final_message.usage.input_tokens,
                output_tokens=final_message.usage.output_tokens
            )

    def get_model_info(self) -> Dict[str, Any]:
        return {
            "name": self.model,
            "provider": "anthropic",
            "supports_vision": True,
            "supports_tools": True,
            "context_window": 200000,
        }
```

### 3.4 BaseTool (도구 시스템)

```python
# hdsp_agent/tools/base.py
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional, Callable, Awaitable
from pydantic import BaseModel, Field
from enum import Enum
import asyncio

class ToolResult(BaseModel):
    """도구 실행 결과."""
    success: bool
    output: Optional[str] = None
    error: Optional[str] = None
    metadata: Dict[str, Any] = Field(default_factory=dict)

class ToolStatus(str, Enum):
    PENDING = "pending"
    APPROVED = "approved"
    REJECTED = "rejected"
    COMPLETED = "completed"
    FAILED = "failed"

class BaseTool(ABC):
    """
    도구 기반 클래스.
    Roo-Code의 BaseTool 패턴 적용.
    """

    # 클래스 레벨 속성
    name: str
    description: str
    parameters_schema: Dict[str, Any]
    requires_approval: bool = True

    def __init__(self):
        self.status = ToolStatus.PENDING
        self._callbacks: Dict[str, Callable] = {}

    @abstractmethod
    async def execute(self, params: Dict[str, Any]) -> ToolResult:
        """
        도구 실행.

        Args:
            params: 도구 파라미터

        Returns:
            ToolResult: 실행 결과
        """
        pass

    def validate_params(self, params: Dict[str, Any]) -> bool:
        """파라미터 검증."""
        # JSON Schema 기반 검증 구현
        required = self.parameters_schema.get("required", [])
        for field in required:
            if field not in params:
                return False
        return True

    def to_api_format(self) -> Dict[str, Any]:
        """API 형식으로 변환 (Claude tool format)."""
        return {
            "name": self.name,
            "description": self.description,
            "input_schema": self.parameters_schema
        }

    def on_progress(self, callback: Callable[[str], None]) -> None:
        """진행 상황 콜백 등록."""
        self._callbacks["progress"] = callback

    def _emit_progress(self, message: str) -> None:
        """진행 상황 알림."""
        if "progress" in self._callbacks:
            self._callbacks["progress"](message)


# hdsp_agent/tools/execute_code.py
class ExecuteCodeTool(BaseTool):
    """Jupyter 커널에서 코드 실행."""

    name = "execute_code"
    description = "Execute Python code in the Jupyter kernel and return the output."
    parameters_schema = {
        "type": "object",
        "properties": {
            "code": {
                "type": "string",
                "description": "Python code to execute"
            },
            "cell_id": {
                "type": "string",
                "description": "Optional cell ID for tracking"
            }
        },
        "required": ["code"]
    }
    requires_approval = True

    def __init__(self, kernel_bridge: 'KernelBridge'):
        super().__init__()
        self.kernel_bridge = kernel_bridge

    async def execute(self, params: Dict[str, Any]) -> ToolResult:
        code = params["code"]
        cell_id = params.get("cell_id")

        try:
            self._emit_progress(f"Executing code ({len(code)} chars)...")

            result = await self.kernel_bridge.execute(
                code,
                cell_id=cell_id
            )

            if result["status"] == "ok":
                return ToolResult(
                    success=True,
                    output=result.get("output", ""),
                    metadata={
                        "execution_count": result.get("execution_count"),
                        "cell_id": cell_id
                    }
                )
            else:
                return ToolResult(
                    success=False,
                    error=result.get("error", "Unknown error"),
                    metadata={"traceback": result.get("traceback")}
                )

        except Exception as e:
            return ToolResult(
                success=False,
                error=str(e)
            )


# hdsp_agent/tools/read_file.py
class ReadFileTool(BaseTool):
    """파일 읽기."""

    name = "read_file"
    description = "Read the contents of a file at the specified path."
    parameters_schema = {
        "type": "object",
        "properties": {
            "path": {
                "type": "string",
                "description": "Absolute path to the file"
            },
            "start_line": {
                "type": "integer",
                "description": "Start line (1-indexed)"
            },
            "end_line": {
                "type": "integer",
                "description": "End line (inclusive)"
            }
        },
        "required": ["path"]
    }
    requires_approval = False  # 읽기는 자동 승인

    async def execute(self, params: Dict[str, Any]) -> ToolResult:
        from pathlib import Path

        path = Path(params["path"])
        start_line = params.get("start_line", 1)
        end_line = params.get("end_line")

        try:
            if not path.exists():
                return ToolResult(
                    success=False,
                    error=f"File not found: {path}"
                )

            if not path.is_file():
                return ToolResult(
                    success=False,
                    error=f"Not a file: {path}"
                )

            content = path.read_text(encoding="utf-8")
            lines = content.split("\n")

            # 라인 범위 처리
            if end_line:
                lines = lines[start_line - 1:end_line]
            elif start_line > 1:
                lines = lines[start_line - 1:]

            # 라인 번호 추가
            numbered_lines = [
                f"{i + start_line:6d}→{line}"
                for i, line in enumerate(lines)
            ]

            return ToolResult(
                success=True,
                output="\n".join(numbered_lines),
                metadata={
                    "path": str(path),
                    "total_lines": len(lines),
                    "start_line": start_line
                }
            )

        except Exception as e:
            return ToolResult(
                success=False,
                error=str(e)
            )
```

### 3.5 TaskManager (작업 관리)

```python
# hdsp_agent/core/task.py
from typing import Optional, List, Dict, Any, Callable
from dataclasses import dataclass, field
from enum import Enum
from datetime import datetime
import uuid
import asyncio

class TaskState(str, Enum):
    IDLE = "idle"
    RUNNING = "running"
    WAITING_APPROVAL = "waiting_approval"
    PAUSED = "paused"
    COMPLETED = "completed"
    ABORTED = "aborted"

@dataclass
class TaskMessage:
    """작업 메시지."""
    ts: float
    type: str  # "user", "assistant", "tool_use", "tool_result"
    content: str
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class Task:
    """작업 인스턴스."""
    task_id: str
    state: TaskState
    messages: List[TaskMessage] = field(default_factory=list)
    api_history: List[Dict[str, Any]] = field(default_factory=list)
    created_at: datetime = field(default_factory=datetime.now)

    # 체크포인트 관련
    checkpoint_enabled: bool = True
    checkpoint_hashes: Dict[float, str] = field(default_factory=dict)  # ts -> hash

    # 컨텍스트 관리
    condense_marker: Optional[float] = None
    truncate_marker: Optional[float] = None

class TaskManager:
    """
    작업 관리자.
    Roo-Code의 Task 오케스트레이션 패턴 적용.
    """

    def __init__(
        self,
        llm_provider: 'BaseLLMProvider',
        tool_registry: 'ToolRegistry',
        state_proxy: 'StateProxy',
        kernel_bridge: 'KernelBridge',
    ):
        self.llm_provider = llm_provider
        self.tool_registry = tool_registry
        self.state_proxy = state_proxy
        self.kernel_bridge = kernel_bridge

        self.current_task: Optional[Task] = None
        self._abort_flag = False
        self._callbacks: Dict[str, List[Callable]] = {}

    async def start_task(self, initial_message: str) -> Task:
        """새 작업 시작."""
        task_id = str(uuid.uuid4())[:8]

        self.current_task = Task(
            task_id=task_id,
            state=TaskState.RUNNING,
        )

        # 사용자 메시지 추가
        self._add_message("user", initial_message)

        # 에이전트 루프 시작
        await self._agent_loop()

        return self.current_task

    async def _agent_loop(self) -> None:
        """에이전트 실행 루프."""
        while not self._abort_flag and self.current_task:
            task = self.current_task

            if task.state != TaskState.RUNNING:
                break

            try:
                # 시스템 프롬프트 생성
                system_prompt = await self._build_system_prompt()

                # API 메시지 변환
                api_messages = self._build_api_messages()

                # 도구 스키마 가져오기
                tools = self.tool_registry.get_tool_schemas()

                # LLM 호출
                assistant_content = []
                tool_uses = []

                async for chunk in self.llm_provider.create_message(
                    system_prompt=system_prompt,
                    messages=api_messages,
                    tools=tools
                ):
                    if chunk.type == "text":
                        assistant_content.append(chunk.text)
                        self._emit("text_delta", chunk.text)

                    elif chunk.type == "tool_use":
                        tool_uses.append({
                            "id": chunk.tool_use_id,
                            "name": chunk.tool_name,
                            "input": {}
                        })

                    elif chunk.type == "tool_input_delta":
                        if tool_uses:
                            # JSON 조립
                            pass

                    elif chunk.type == "done":
                        self._emit("usage", {
                            "input": chunk.input_tokens,
                            "output": chunk.output_tokens
                        })

                # 어시스턴트 응답 추가
                full_text = "".join(assistant_content)
                if full_text:
                    self._add_message("assistant", full_text)

                # 도구 실행
                if tool_uses:
                    for tool_use in tool_uses:
                        await self._execute_tool(
                            tool_use["id"],
                            tool_use["name"],
                            tool_use["input"]
                        )
                else:
                    # 도구 사용 없으면 완료
                    task.state = TaskState.COMPLETED
                    break

            except Exception as e:
                self._emit("error", str(e))
                task.state = TaskState.ABORTED
                break

    async def _execute_tool(
        self,
        tool_id: str,
        tool_name: str,
        tool_input: Dict[str, Any]
    ) -> None:
        """도구 실행."""
        tool = self.tool_registry.get_tool(tool_name)

        if not tool:
            self._add_message("tool_result", f"Unknown tool: {tool_name}", {
                "tool_use_id": tool_id,
                "is_error": True
            })
            return

        # 승인 필요 여부 확인
        if tool.requires_approval:
            self.current_task.state = TaskState.WAITING_APPROVAL
            self._emit("approval_required", {
                "tool_name": tool_name,
                "tool_input": tool_input
            })

            # 승인 대기
            approved = await self._wait_for_approval()

            if not approved:
                self._add_message("tool_result", "Tool execution rejected by user", {
                    "tool_use_id": tool_id,
                    "is_error": True
                })
                self.current_task.state = TaskState.RUNNING
                return

        # 도구 실행
        self.current_task.state = TaskState.RUNNING
        self._emit("tool_start", tool_name)

        result = await tool.execute(tool_input)

        self._add_message("tool_result", result.output or result.error, {
            "tool_use_id": tool_id,
            "is_error": not result.success
        })

        self._emit("tool_complete", {
            "name": tool_name,
            "success": result.success
        })

    def _add_message(
        self,
        msg_type: str,
        content: str,
        metadata: Dict[str, Any] = None
    ) -> None:
        """메시지 추가."""
        import time

        message = TaskMessage(
            ts=time.time() * 1000,
            type=msg_type,
            content=content,
            metadata=metadata or {}
        )

        self.current_task.messages.append(message)
        self._emit("message", message)

    def _build_api_messages(self) -> List['Message']:
        """API 메시지 변환."""
        from hdsp_agent.providers.base import Message, ContentBlock, MessageRole

        messages = []
        task = self.current_task

        # condense/truncate 마커 이후 메시지만 포함
        start_ts = max(
            task.condense_marker or 0,
            task.truncate_marker or 0
        )

        for msg in task.messages:
            if msg.ts <= start_ts:
                continue

            if msg.type == "user":
                messages.append(Message(
                    role=MessageRole.USER,
                    content=[ContentBlock(type="text", text=msg.content)]
                ))
            elif msg.type == "assistant":
                messages.append(Message(
                    role=MessageRole.ASSISTANT,
                    content=[ContentBlock(type="text", text=msg.content)]
                ))
            # tool_use, tool_result 등 추가 처리

        return messages

    async def _build_system_prompt(self) -> str:
        """시스템 프롬프트 생성."""
        state = self.state_proxy.get()

        # 프롬프트 섹션 조합
        sections = [
            self._get_role_definition(state.mode),
            self._get_tools_section(),
            self._get_rules_section(),
            state.custom_instructions,
        ]

        return "\n\n".join(filter(None, sections))

    def on(self, event: str, callback: Callable) -> None:
        """이벤트 리스너 등록."""
        if event not in self._callbacks:
            self._callbacks[event] = []
        self._callbacks[event].append(callback)

    def _emit(self, event: str, data: Any = None) -> None:
        """이벤트 발생."""
        for callback in self._callbacks.get(event, []):
            callback(data)

    def abort(self) -> None:
        """작업 중단."""
        self._abort_flag = True
        if self.current_task:
            self.current_task.state = TaskState.ABORTED
```

### 3.6 KernelBridge (Jupyter 커널 통신)

```python
# hdsp_agent/kernel/bridge.py
from typing import Optional, Dict, Any, Callable
import asyncio
from jupyter_client import AsyncKernelClient
from jupyter_client.manager import AsyncKernelManager

class KernelBridge:
    """
    Jupyter 커널 브릿지.
    - 비동기 코드 실행
    - 출력 스트리밍
    - 인터럽트 처리
    """

    def __init__(self, kernel_manager: Optional[AsyncKernelManager] = None):
        self.kernel_manager = kernel_manager
        self.client: Optional[AsyncKernelClient] = None
        self._output_callbacks: list[Callable] = []

    async def connect(
        self,
        connection_file: Optional[str] = None
    ) -> None:
        """커널 연결."""
        if connection_file:
            # 기존 커널에 연결
            self.client = AsyncKernelClient()
            self.client.load_connection_file(connection_file)
        elif self.kernel_manager:
            # 매니저에서 클라이언트 획득
            self.client = self.kernel_manager.client()
        else:
            raise ValueError("No kernel connection available")

        self.client.start_channels()
        await self.client.wait_for_ready()

    async def execute(
        self,
        code: str,
        cell_id: Optional[str] = None,
        silent: bool = False
    ) -> Dict[str, Any]:
        """
        코드 실행.

        Returns:
            Dict with keys: status, output, error, execution_count
        """
        if not self.client:
            raise RuntimeError("Not connected to kernel")

        # 실행 요청
        msg_id = self.client.execute(
            code,
            silent=silent,
            store_history=not silent
        )

        outputs = []
        error = None
        execution_count = None

        # 응답 대기
        while True:
            try:
                msg = await asyncio.wait_for(
                    self.client.get_iopub_msg(),
                    timeout=60.0
                )
            except asyncio.TimeoutError:
                return {
                    "status": "error",
                    "error": "Execution timeout"
                }

            if msg["parent_header"].get("msg_id") != msg_id:
                continue

            msg_type = msg["header"]["msg_type"]
            content = msg["content"]

            if msg_type == "stream":
                # stdout/stderr
                text = content["text"]
                outputs.append(text)
                self._emit_output(text)

            elif msg_type == "execute_result":
                # 실행 결과
                execution_count = content["execution_count"]
                data = content["data"]
                if "text/plain" in data:
                    outputs.append(data["text/plain"])

            elif msg_type == "display_data":
                # 표시 데이터 (이미지 등)
                data = content["data"]
                if "text/plain" in data:
                    outputs.append(data["text/plain"])

            elif msg_type == "error":
                # 에러
                error = {
                    "name": content["ename"],
                    "value": content["evalue"],
                    "traceback": content["traceback"]
                }

            elif msg_type == "status":
                if content["execution_state"] == "idle":
                    break

        if error:
            return {
                "status": "error",
                "error": f"{error['name']}: {error['value']}",
                "traceback": error["traceback"]
            }

        return {
            "status": "ok",
            "output": "\n".join(outputs),
            "execution_count": execution_count
        }

    async def interrupt(self) -> None:
        """커널 인터럽트."""
        if self.kernel_manager:
            await self.kernel_manager.interrupt_kernel()

    async def restart(self) -> None:
        """커널 재시작."""
        if self.kernel_manager:
            await self.kernel_manager.restart_kernel()
            await self.client.wait_for_ready()

    def on_output(self, callback: Callable[[str], None]) -> None:
        """출력 콜백 등록."""
        self._output_callbacks.append(callback)

    def _emit_output(self, text: str) -> None:
        """출력 알림."""
        for callback in self._output_callbacks:
            callback(text)

    async def close(self) -> None:
        """연결 종료."""
        if self.client:
            self.client.stop_channels()
```

## 4. 단계별 구현 로드맵

### Phase 1: 핵심 기반 (2주)

```
Week 1:
├── 프로젝트 구조 설정
│   ├── pyproject.toml 설정
│   ├── 패키지 구조 생성
│   └── 기본 테스트 설정 (pytest)
├── StateProxy 구현
│   ├── Pydantic 스키마 정의
│   ├── 파일 영속성
│   └── keyring 시크릿 관리
└── ConfigManager 구현
    ├── 프로바이더 설정
    └── API 프로필 관리

Week 2:
├── BaseLLMProvider 구현
│   ├── 추상 클래스 정의
│   ├── AnthropicProvider 구현
│   └── 스트리밍 처리
└── BaseTool 구현
    ├── 도구 기반 클래스
    ├── ReadFileTool
    └── WriteFileTool
```

### Phase 2: 에이전트 코어 (2주)

```
Week 3:
├── KernelBridge 구현
│   ├── 커널 연결/관리
│   ├── 코드 실행
│   └── 출력 스트리밍
├── ExecuteCodeTool 구현
└── ToolRegistry 구현
    └── 도구 등록/조회

Week 4:
├── TaskManager 구현
│   ├── 작업 생명주기
│   ├── 에이전트 루프
│   └── 도구 실행 흐름
└── MessageManager 구현
    ├── 메시지 관리
    └── API 히스토리 변환
```

### Phase 3: 사용자 경험 (2주)

```
Week 5:
├── JupyterLab Extension 기본
│   ├── Panel 생성
│   ├── React 컴포넌트
│   └── 상태 바인딩
└── 승인 시스템 UI
    ├── 승인/거부 버튼
    └── 도구 미리보기

Week 6:
├── NotebookCheckpoint 구현
│   ├── 노트북 메타데이터 기반
│   └── 되감기 기능
└── 기본 MCP 통합
    └── MCP 클라이언트
```

### Phase 4: 고급 기능 (2주)

```
Week 7:
├── ContextCondenser 구현
│   ├── 요약 전략
│   └── 토큰 관리
└── 다중 프로바이더 지원
    ├── OpenAI
    └── 로컬 모델 (Ollama)

Week 8:
├── 세션 영속성
│   ├── 작업 저장/복원
│   └── 히스토리 관리
└── 텔레메트리
    └── 사용 통계 수집
```

## 5. 잠재적 함정 및 주의사항

### 5.1 커널 통신 관련

```python
# ❌ 잘못된 패턴: 동기 실행
def execute_code(code: str) -> str:
    # 블로킹 호출 - UI 멈춤
    result = kernel.execute(code)
    return result

# ✅ 올바른 패턴: 비동기 + 타임아웃
async def execute_code(code: str, timeout: float = 60.0) -> str:
    try:
        result = await asyncio.wait_for(
            kernel.execute_async(code),
            timeout=timeout
        )
        return result
    except asyncio.TimeoutError:
        await kernel.interrupt()
        raise ExecutionTimeoutError(f"Code execution timed out after {timeout}s")
```

### 5.2 상태 관리 관련

```python
# ❌ 잘못된 패턴: 직접 상태 수정
class Task:
    def update_status(self):
        self.state["status"] = "running"  # 검증 없음
        self._save()  # 무효한 상태 저장 가능

# ✅ 올바른 패턴: Pydantic 검증
class Task:
    def update_status(self, new_status: TaskState):
        # Pydantic이 자동 검증
        self.state = TaskState(
            **self.state.model_dump(),
            status=new_status
        )
        self._save()
```

### 5.3 메시지 히스토리 관련

```python
# ❌ 잘못된 패턴: 직접 삭제
def delete_message(self, ts: float):
    self.messages = [m for m in self.messages if m.ts != ts]
    # 체크포인트 매핑, API 히스토리 정합성 깨짐

# ✅ 올바른 패턴: 비파괴적 마킹
def hide_messages_after(self, ts: float):
    self.truncate_marker = ts
    # 메시지 유지, 표시/API 변환에서 필터링
```

### 5.4 도구 승인 관련

```python
# ❌ 잘못된 패턴: 무한 대기
async def wait_for_approval(self):
    while True:
        if self.approved:
            return True
        await asyncio.sleep(0.1)  # CPU 낭비, 취소 불가

# ✅ 올바른 패턴: 이벤트 기반 + 타임아웃
async def wait_for_approval(self, timeout: float = 300.0):
    try:
        return await asyncio.wait_for(
            self._approval_event.wait(),
            timeout=timeout
        )
    except asyncio.TimeoutError:
        return False  # 타임아웃 시 자동 거부
```

### 5.5 LLM 스트리밍 관련

```python
# ❌ 잘못된 패턴: 전체 응답 대기
async def get_response(self):
    response = await self.client.create_message(...)
    return response.content  # 전체 응답 후 반환

# ✅ 올바른 패턴: 청크 단위 처리
async def get_response(self):
    full_text = []
    async for chunk in self.client.create_message_stream(...):
        if chunk.type == "text":
            full_text.append(chunk.text)
            yield chunk  # 즉시 UI 업데이트
    return "".join(full_text)
```

### 5.6 체크포인트 관련

```python
# ❌ 잘못된 패턴: 노트북 직접 덮어쓰기
def restore_checkpoint(self, checkpoint):
    self.notebook = checkpoint["notebook"]  # 현재 상태 손실

# ✅ 올바른 패턴: 메타데이터 기반 복원
def restore_checkpoint(self, checkpoint_id: str):
    # 현재 상태 백업
    backup = self._create_backup()

    try:
        # 체크포인트 복원
        checkpoint_data = self._load_checkpoint(checkpoint_id)
        self._apply_checkpoint(checkpoint_data)

        # 복원 후 새 체크포인트 생성 (복원 이력 유지)
        self._save_checkpoint(f"restored_from_{checkpoint_id}")
    except Exception as e:
        # 실패 시 백업 복원
        self._apply_checkpoint(backup)
        raise
```

## 6. 테스트 전략

### 6.1 단위 테스트

```python
# tests/test_state_proxy.py
import pytest
from hdsp_agent.core.state import StateProxy, GlobalState

class TestStateProxy:
    @pytest.fixture
    def state_proxy(self, tmp_path):
        return StateProxy.initialize(
            GlobalState,
            tmp_path / "state.json"
        )

    def test_load_default(self, state_proxy):
        state = state_proxy.get()
        assert state.mode == "code"
        assert state.auto_approval_enabled == False

    def test_update_with_validation(self, state_proxy):
        state_proxy.update(mode="architect")
        assert state_proxy.get().mode == "architect"

    def test_persistence(self, state_proxy, tmp_path):
        state_proxy.update(language="ko")
        state_proxy.save()

        # 새 인스턴스로 로드
        new_proxy = StateProxy(GlobalState, tmp_path / "state.json")
        assert new_proxy.get().language == "ko"
```

### 6.2 통합 테스트

```python
# tests/integration/test_agent_loop.py
import pytest
from unittest.mock import AsyncMock, MagicMock

class TestAgentLoop:
    @pytest.fixture
    async def task_manager(self, mock_provider, mock_kernel):
        from hdsp_agent.core.task import TaskManager

        manager = TaskManager(
            llm_provider=mock_provider,
            tool_registry=mock_registry,
            state_proxy=mock_state,
            kernel_bridge=mock_kernel
        )
        return manager

    @pytest.mark.asyncio
    async def test_simple_conversation(self, task_manager, mock_provider):
        # 단순 텍스트 응답 설정
        mock_provider.create_message = AsyncMock(return_value=async_generator([
            StreamChunk(type="text", text="Hello!"),
            StreamChunk(type="done", input_tokens=10, output_tokens=5)
        ]))

        task = await task_manager.start_task("Say hello")

        assert task.state == TaskState.COMPLETED
        assert len(task.messages) == 2  # user + assistant

    @pytest.mark.asyncio
    async def test_tool_execution(self, task_manager, mock_provider, mock_kernel):
        # 도구 사용 응답 설정
        mock_provider.create_message = AsyncMock(return_value=async_generator([
            StreamChunk(type="tool_use", tool_use_id="1", tool_name="execute_code"),
            StreamChunk(type="done", input_tokens=20, output_tokens=10)
        ]))

        mock_kernel.execute = AsyncMock(return_value={
            "status": "ok",
            "output": "Hello World"
        })

        # 자동 승인 설정
        task_manager._wait_for_approval = AsyncMock(return_value=True)

        task = await task_manager.start_task("Run print('Hello World')")

        mock_kernel.execute.assert_called_once()
```

### 6.3 E2E 테스트

```python
# tests/e2e/test_full_workflow.py
import pytest
from jupyter_client import KernelManager

class TestFullWorkflow:
    @pytest.fixture
    async def real_kernel(self):
        """실제 Jupyter 커널 사용."""
        km = KernelManager(kernel_name="python3")
        km.start_kernel()
        yield km
        km.shutdown_kernel()

    @pytest.mark.integration
    @pytest.mark.asyncio
    async def test_code_execution_e2e(self, real_kernel):
        from hdsp_agent.kernel.bridge import KernelBridge

        bridge = KernelBridge(real_kernel)
        await bridge.connect()

        result = await bridge.execute("2 + 2")

        assert result["status"] == "ok"
        assert "4" in result["output"]

        await bridge.close()
```

## 7. 최종 체크리스트

### 구현 완료 확인

- [ ] StateProxy: 상태 관리 + Pydantic 검증
- [ ] ConfigManager: 설정 및 프로필 관리
- [ ] BaseLLMProvider: LLM 추상화 + 스트리밍
- [ ] AnthropicProvider: Claude API 통합
- [ ] BaseTool: 도구 기반 클래스
- [ ] ExecuteCodeTool: 코드 실행 도구
- [ ] ReadFileTool / WriteFileTool: 파일 도구
- [ ] KernelBridge: Jupyter 커널 통신
- [ ] TaskManager: 작업 오케스트레이션
- [ ] MessageManager: 메시지 관리
- [ ] NotebookCheckpoint: 체크포인트 시스템
- [ ] JupyterLab Panel: UI 패널

### 테스트 완료 확인

- [ ] 단위 테스트 커버리지 > 80%
- [ ] 통합 테스트 주요 시나리오
- [ ] E2E 테스트 실제 커널 사용

### 문서화 완료 확인

- [ ] API 문서 (Sphinx/mkdocs)
- [ ] 설치 가이드
- [ ] 사용자 가이드
- [ ] 개발자 가이드

## 8. 참고 자료

### Roo-Code 핵심 파일

| 컴포넌트 | Roo-Code 파일 | 참고 줄 수 |
|----------|---------------|-----------|
| 상태 관리 | `src/core/config/ContextProxy.ts` | 442 |
| 작업 관리 | `src/core/task/Task.ts` | 1000+ |
| 도구 시스템 | `src/core/tools/BaseTool.ts` | ~200 |
| MCP 통합 | `src/services/mcp/McpServerManager.ts` | ~300 |
| 체크포인트 | `src/services/checkpoints/ShadowCheckpointService.ts` | 510 |
| 메시지 | `src/core/message-manager/index.ts` | 186 |
| 프롬프트 | `src/core/prompts/system.ts` | 150+ |

### Python 생태계 도구

- **상태 관리**: Pydantic, keyring
- **LLM 클라이언트**: anthropic, openai
- **Jupyter 통신**: jupyter_client
- **비동기**: asyncio, aiofiles
- **테스트**: pytest, pytest-asyncio
- **빌드**: hatchling, jupyter-packaging
- **UI**: JupyterLab Extension (TypeScript + React)
