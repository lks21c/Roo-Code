# ë„êµ¬(Tool) ì‹œìŠ¤í…œ

> Roo-Codeì˜ ë„êµ¬ ì‹œìŠ¤í…œì„ ë¶„ì„í•˜ê³ , Jupyter ê¸°ë°˜ hdsp-agentì— ì ìš©í•  ìˆ˜ ìˆëŠ” íŒ¨í„´ì„ ì œì‹œí•©ë‹ˆë‹¤.

## ëª©ì°¨
1. [BaseTool ì¶”ìƒ í´ë˜ìŠ¤](#1-basetool-ì¶”ìƒ-í´ë˜ìŠ¤)
2. [ì´ì¤‘ í”„ë¡œí† ì½œ ì§€ì›](#2-ì´ì¤‘-í”„ë¡œí† ì½œ-ì§€ì›)
3. [ë„êµ¬ ëª©ë¡ ë° ì—­í• ](#3-ë„êµ¬-ëª©ë¡-ë°-ì—­í• )
4. [ë„êµ¬ ì‹¤í–‰ íë¦„](#4-ë„êµ¬-ì‹¤í–‰-íë¦„)
5. [ê¶Œí•œ ë° ìŠ¹ì¸ ì‹œìŠ¤í…œ](#5-ê¶Œí•œ-ë°-ìŠ¹ì¸-ì‹œìŠ¤í…œ)
6. [Jupyter ì ìš© ê°€ì´ë“œ](#6-jupyter-ì ìš©-ê°€ì´ë“œ)

---

## 1. BaseTool ì¶”ìƒ í´ë˜ìŠ¤

### í•µì‹¬ êµ¬ì¡°

```typescript
// src/core/tools/BaseTool.ts

/**
 * ëª¨ë“  ë„êµ¬ì˜ ì¶”ìƒ ê¸°ë³¸ í´ë˜ìŠ¤
 *
 * ì•„í‚¤í…ì²˜:
 * - XML/ë ˆê±°ì‹œ í”„ë¡œí† ì½œ: params â†’ parseLegacy() â†’ íƒ€ì…ëœ params â†’ execute()
 * - ë„¤ì´í‹°ë¸Œ í”„ë¡œí† ì½œ: nativeArgsê°€ ì´ë¯¸ íƒ€ì…ëœ ë°ì´í„° â†’ execute()
 */
export abstract class BaseTool<TName extends ToolName> {
    /**
     * ë„êµ¬ ì´ë¦„ (ToolName íƒ€ì…ê³¼ ì¼ì¹˜í•´ì•¼ í•¨)
     */
    abstract readonly name: TName

    /**
     * XML/ë ˆê±°ì‹œ ë¬¸ìì—´ íŒŒë¼ë¯¸í„°ë¥¼ íƒ€ì…ëœ íŒŒë¼ë¯¸í„°ë¡œ íŒŒì‹±
     */
    abstract parseLegacy(
        params: Partial<Record<string, string>>
    ): ToolParams<TName>

    /**
     * íƒ€ì…ëœ íŒŒë¼ë¯¸í„°ë¡œ ë„êµ¬ ì‹¤í–‰
     * í”„ë¡œí† ì½œì— ë…ë¦½ì ì¸ í•µì‹¬ ë¡œì§
     */
    abstract execute(
        params: ToolParams<TName>,
        task: Task,
        callbacks: ToolCallbacks
    ): Promise<void>

    /**
     * ìŠ¤íŠ¸ë¦¬ë° ë¶€ë¶„ ë©”ì‹œì§€ ì²˜ë¦¬ (ì„ íƒì )
     * ê¸°ë³¸ êµ¬í˜„ì€ ì•„ë¬´ê²ƒë„ í•˜ì§€ ì•ŠìŒ
     */
    async handlePartial(task: Task, block: ToolUse<TName>): Promise<void> {
        // ê¸°ë³¸: ë¶€ë¶„ ë©”ì‹œì§€ì— ëŒ€í•´ ì•„ë¬´ê²ƒë„ ì•ˆí•¨
        // ìŠ¤íŠ¸ë¦¬ë° UI ì—…ë°ì´íŠ¸ë¥¼ ìœ„í•´ ì˜¤ë²„ë¼ì´ë“œ ê°€ëŠ¥
    }

    /**
     * ë©”ì¸ ì§„ì…ì 
     * 1. ë¶€ë¶„ ë©”ì‹œì§€ ì²˜ë¦¬
     * 2. íŒŒë¼ë¯¸í„° íŒŒì‹± (XMLìš© parseLegacy ë˜ëŠ” ì§ì ‘ nativeArgs ì‚¬ìš©)
     * 3. í•µì‹¬ ì‹¤í–‰ (execute)
     */
    async handle(
        task: Task,
        block: ToolUse<TName>,
        callbacks: ToolCallbacks
    ): Promise<void> {
        // ë¶€ë¶„ ë©”ì‹œì§€ ì²˜ë¦¬
        if (block.partial) {
            try {
                await this.handlePartial(task, block)
            } catch (error) {
                await callbacks.handleError(
                    `handling partial ${this.name}`,
                    error instanceof Error ? error : new Error(String(error))
                )
            }
            return
        }

        // í”„ë¡œí† ì½œ ê²°ì • ë° íŒŒë¼ë¯¸í„° íŒŒì‹±
        let params: ToolParams<TName>
        try {
            if (block.nativeArgs !== undefined) {
                // ë„¤ì´í‹°ë¸Œ í”„ë¡œí† ì½œ: NativeToolCallParserê°€ ì œê³µí•œ íƒ€ì…ëœ args
                params = block.nativeArgs as ToolParams<TName>
            } else {
                // XML/ë ˆê±°ì‹œ í”„ë¡œí† ì½œ: ë¬¸ìì—´ paramsë¥¼ íƒ€ì…ëœ paramsë¡œ íŒŒì‹±
                params = this.parseLegacy(block.params)
            }
        } catch (error) {
            const errorMessage = `Failed to parse ${this.name} parameters`
            await callbacks.handleError(`parsing ${this.name} args`, new Error(errorMessage))
            callbacks.pushToolResult(`<error>${errorMessage}</error>`)
            return
        }

        // íƒ€ì…ëœ íŒŒë¼ë¯¸í„°ë¡œ ì‹¤í–‰
        await this.execute(params, task, callbacks)
    }

    /**
     * ìŠ¤íŠ¸ë¦¬ë° ì¤‘ ë¶€ë¶„ ë‹«ëŠ” XML íƒœê·¸ ì œê±°
     */
    protected removeClosingTag(
        tag: string,
        text: string | undefined,
        isPartial: boolean
    ): string {
        if (!isPartial || !text) {
            return text || ""
        }

        const tagRegex = new RegExp(
            `\\s?<\/?${tag
                .split("")
                .map((char) => `(?:${char})?`)
                .join("")}$`,
            "g"
        )

        return text.replace(tagRegex, "")
    }
}
```

### ToolCallbacks ì¸í„°í˜ì´ìŠ¤

```typescript
// src/core/tools/BaseTool.ts

export interface ToolCallbacks {
    /**
     * ìŠ¹ì¸ ìš”ì²­
     */
    askApproval: (
        type: ClineAsk,
        partialMessage?: string,
        progressStatus?: ToolProgressStatus,
        forceApproval?: boolean
    ) => Promise<boolean>

    /**
     * ì˜¤ë¥˜ ì²˜ë¦¬
     */
    handleError: (action: string, error: Error) => Promise<void>

    /**
     * ë„êµ¬ ê²°ê³¼ í‘¸ì‹œ
     */
    pushToolResult: (content: ToolResponse) => void

    /**
     * ë‹«ëŠ” íƒœê·¸ ì œê±°
     */
    removeClosingTag: (tag: ToolParamName, content?: string) => string

    /**
     * í˜„ì¬ ë„êµ¬ í”„ë¡œí† ì½œ
     */
    toolProtocol: ToolProtocol

    /**
     * ë„êµ¬ í˜¸ì¶œ ID (ë„¤ì´í‹°ë¸Œ í”„ë¡œí† ì½œ)
     */
    toolCallId?: string
}
```

---

## 2. ì´ì¤‘ í”„ë¡œí† ì½œ ì§€ì›

### XML í”„ë¡œí† ì½œ

```xml
<!-- ëª¨ë¸ì´ ìƒì„±í•˜ëŠ” XML í˜•ì‹ -->
<read_file>
    <path>/src/main.ts</path>
    <start_line>1</start_line>
    <end_line>50</end_line>
</read_file>

<execute_command>
    <command>npm install</command>
    <cwd>/project</cwd>
</execute_command>

<write_to_file>
    <path>/src/utils.ts</path>
    <content>
export function helper() {
    return "hello"
}
    </content>
</write_to_file>
```

### ë„¤ì´í‹°ë¸Œ í”„ë¡œí† ì½œ (OpenAI ìŠ¤íƒ€ì¼)

```json
{
    "type": "function",
    "function": {
        "name": "read_file",
        "arguments": {
            "files": [
                {
                    "path": "/src/main.ts",
                    "start_line": 1,
                    "end_line": 50
                }
            ]
        }
    }
}
```

### NativeToolArgs íƒ€ì… ë§µ

```typescript
// src/shared/tools.ts

/**
 * ê° ë„êµ¬ì˜ ë„¤ì´í‹°ë¸Œ(íƒ€ì…ëœ) ì¸ì êµ¬ì¡° ì •ì˜
 * ì—¬ê¸°ì— ì—†ëŠ” ë„êµ¬ëŠ” í•˜ìœ„ í˜¸í™˜ì„±ì„ ìœ„í•´ `any`ë¡œ í´ë°±
 */
export type NativeToolArgs = {
    access_mcp_resource: { server_name: string; uri: string }
    read_file: { files: FileEntry[] }
    attempt_completion: { result: string }
    execute_command: { command: string; cwd?: string }
    apply_diff: { path: string; diff: string }
    search_and_replace: {
        path: string
        operations: Array<{ search: string; replace: string }>
    }
    search_replace: {
        file_path: string
        old_string: string
        new_string: string
    }
    apply_patch: { patch: string }
    ask_followup_question: {
        question: string
        follow_up: Array<{ text: string; mode?: string }>
    }
    browser_action: BrowserActionParams
    codebase_search: { query: string; path?: string }
    fetch_instructions: { task: string }
    generate_image: GenerateImageParams
    run_slash_command: { command: string; args?: string }
    search_files: {
        path: string
        regex: string
        file_pattern?: string | null
    }
    switch_mode: { mode_slug: string; reason: string }
    update_todo_list: { todos: string }
    use_mcp_tool: {
        server_name: string
        tool_name: string
        arguments?: Record<string, unknown>
    }
    write_to_file: { path: string; content: string }
}
```

### í”„ë¡œí† ì½œ ì„ íƒ ë¡œì§

```typescript
// í”„ë¡œí† ì½œ ê²°ì • ë¡œì§
function resolveToolProtocol(
    config: ProviderSettings,
    modelInfo: ModelInfo
): ToolProtocol {
    // 1. ëª…ì‹œì  ì„¤ì • í™•ì¸
    if (config.toolProtocol) {
        return config.toolProtocol
    }

    // 2. ëª¨ë¸ ì§€ì› ì—¬ë¶€ í™•ì¸
    if (modelInfo.supportsNativeToolCalling) {
        return "native"
    }

    // 3. ê¸°ë³¸ê°’: XML
    return "xml"
}
```

---

## 3. ë„êµ¬ ëª©ë¡ ë° ì—­í• 

### ì½”ì–´ ë„êµ¬ (20+)

| ë„êµ¬ | íŒŒì¼ | ì„¤ëª… | ì¹´í…Œê³ ë¦¬ |
|------|------|------|----------|
| `read_file` | ReadFileTool.ts | íŒŒì¼ ì½ê¸° | ì½ê¸° |
| `write_to_file` | WriteToFileTool.ts | íŒŒì¼ ì“°ê¸° | ì“°ê¸° |
| `apply_diff` | ApplyDiffTool.ts | ì°¨ì´ ì ìš© | ì“°ê¸° |
| `search_replace` | SearchReplaceTool.ts | ê²€ìƒ‰/ì¹˜í™˜ | ì“°ê¸° |
| `search_and_replace` | SearchAndReplaceTool.ts | ë‹¤ì¤‘ ê²€ìƒ‰/ì¹˜í™˜ | ì“°ê¸° |
| `multi_apply_diff` | MultiApplyDiffTool.ts | ë‹¤ì¤‘ íŒŒì¼ ì°¨ì´ ì ìš© | ì“°ê¸° |
| `apply_patch` | ApplyPatchTool.ts | íŒ¨ì¹˜ ì ìš© | ì“°ê¸° |
| `list_files` | ListFilesTool.ts | íŒŒì¼ ëª©ë¡ | ì½ê¸° |
| `search_files` | SearchFilesTool.ts | íŒŒì¼ ê²€ìƒ‰ (regex) | ì½ê¸° |
| `codebase_search` | CodebaseSearchTool.ts | ì½”ë“œë² ì´ìŠ¤ ê²€ìƒ‰ | ì½ê¸° |
| `execute_command` | ExecuteCommandTool.ts | ëª…ë ¹ì–´ ì‹¤í–‰ | ì‹¤í–‰ |
| `browser_action` | BrowserActionTool.ts | ë¸Œë¼ìš°ì € ë™ì‘ | ë¸Œë¼ìš°ì € |
| `use_mcp_tool` | UseMcpToolTool.ts | MCP ë„êµ¬ ì‚¬ìš© | MCP |
| `access_mcp_resource` | accessMcpResourceTool.ts | MCP ë¦¬ì†ŒìŠ¤ ì ‘ê·¼ | MCP |
| `ask_followup_question` | AskFollowupQuestionTool.ts | í›„ì† ì§ˆë¬¸ | ëŒ€í™” |
| `attempt_completion` | AttemptCompletionTool.ts | ì™„ë£Œ ì‹œë„ | ëŒ€í™” |
| `switch_mode` | SwitchModeTool.ts | ëª¨ë“œ ì „í™˜ | ëª¨ë“œ |
| `new_task` | NewTaskTool.ts | ìƒˆ íƒœìŠ¤í¬ ìƒì„± | íƒœìŠ¤í¬ |
| `update_todo_list` | UpdateTodoListTool.ts | TODO ë¦¬ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸ | íƒœìŠ¤í¬ |
| `fetch_instructions` | FetchInstructionsTool.ts | ì§€ì‹œì‚¬í•­ ê°€ì ¸ì˜¤ê¸° | ê¸°íƒ€ |
| `generate_image` | GenerateImageTool.ts | ì´ë¯¸ì§€ ìƒì„± | ê¸°íƒ€ |
| `run_slash_command` | RunSlashCommandTool.ts | ìŠ¬ë˜ì‹œ ëª…ë ¹ ì‹¤í–‰ | ê¸°íƒ€ |

### ë„êµ¬ ê·¸ë£¹

```typescript
// packages/types/src/tool.ts (ê°œë…ì )

type ToolGroup =
    | "read"      // ì½ê¸° ì „ìš© ë„êµ¬
    | "edit"      // í¸ì§‘ ë„êµ¬
    | "browser"   // ë¸Œë¼ìš°ì € ë„êµ¬
    | "command"   // ëª…ë ¹ ì‹¤í–‰ ë„êµ¬
    | "mcp"       // MCP ë„êµ¬
    | "modes"     // ëª¨ë“œ ê´€ë ¨ ë„êµ¬

// ê·¸ë£¹ë³„ ë„êµ¬ ë§¤í•‘
const toolGroups: Record<ToolGroup, ToolName[]> = {
    read: [
        "read_file",
        "list_files",
        "search_files",
        "codebase_search"
    ],
    edit: [
        "write_to_file",
        "apply_diff",
        "search_replace",
        "search_and_replace",
        "multi_apply_diff",
        "apply_patch"
    ],
    browser: [
        "browser_action"
    ],
    command: [
        "execute_command"
    ],
    mcp: [
        "use_mcp_tool",
        "access_mcp_resource"
    ],
    modes: [
        "switch_mode",
        "new_task"
    ]
}
```

---

## 4. ë„êµ¬ ì‹¤í–‰ íë¦„

### ì „ì²´ íë¦„ ë‹¤ì´ì–´ê·¸ë¨

```mermaid
flowchart TD
    subgraph "1. Tool Call Detection"
        A[API ì‘ë‹µ ìŠ¤íŠ¸ë¦¬ë°]
        B{í”„ë¡œí† ì½œ?}
        B -->|XML| C[AssistantMessageParser]
        B -->|Native| D[NativeToolCallParser]
    end

    subgraph "2. Tool Dispatch"
        C --> E[ToolUse ë¸”ë¡ ìƒì„±]
        D --> E
        E --> F[ë„êµ¬ ì¸ìŠ¤í„´ìŠ¤ ì¡°íšŒ]
        F --> G[BaseTool.handle()]
    end

    subgraph "3. Parameter Parsing"
        G --> H{partial?}
        H -->|Yes| I[handlePartial()]
        H -->|No| J{nativeArgs?}
        J -->|Yes| K[ì§ì ‘ ì‚¬ìš©]
        J -->|No| L[parseLegacy()]
    end

    subgraph "4. Approval"
        K --> M[checkAutoApproval()]
        L --> M
        M --> N{ìë™ ìŠ¹ì¸?}
        N -->|Yes| O[execute()]
        N -->|No| P[ì‚¬ìš©ì ìŠ¹ì¸ ìš”ì²­]
        P --> Q{ìŠ¹ì¸ë¨?}
        Q -->|Yes| O
        Q -->|No| R[ì·¨ì†Œë¨]
    end

    subgraph "5. Execution"
        O --> S[ë„êµ¬ ë¡œì§ ì‹¤í–‰]
        S --> T[pushToolResult()]
        T --> U[API íˆìŠ¤í† ë¦¬ì— ê²°ê³¼ ì¶”ê°€]
    end

    A --> B
    I --> Z[ì¢…ë£Œ]
    R --> Z
    U --> Z
```

### êµ¬ì²´ì ì¸ ë„êµ¬ êµ¬í˜„ ì˜ˆì‹œ: ReadFileTool

```typescript
// src/core/tools/ReadFileTool.ts (ê°œë…ì  êµ¬ì¡°)

export class ReadFileTool extends BaseTool<"read_file"> {
    readonly name = "read_file" as const

    /**
     * XML íŒŒë¼ë¯¸í„°ë¥¼ íƒ€ì…ëœ íŒŒë¼ë¯¸í„°ë¡œ íŒŒì‹±
     */
    parseLegacy(params: Partial<Record<string, string>>): NativeToolArgs["read_file"] {
        // XML: <path>/src/main.ts</path>
        // â†’ { files: [{ path: "/src/main.ts" }] }

        if (params.path) {
            return {
                files: [{
                    path: params.path,
                    start_line: params.start_line ? parseInt(params.start_line) : undefined,
                    end_line: params.end_line ? parseInt(params.end_line) : undefined
                }]
            }
        }

        // args í˜•ì‹ë„ ì§€ì›
        if (params.args) {
            return this.parseArgsFormat(params.args)
        }

        throw new Error("Missing required parameter: path or files")
    }

    /**
     * í•µì‹¬ ì‹¤í–‰ ë¡œì§
     */
    async execute(
        params: NativeToolArgs["read_file"],
        task: Task,
        callbacks: ToolCallbacks
    ): Promise<void> {
        const { files } = params

        // 1. ìŠ¹ì¸ í™•ì¸
        const approved = await callbacks.askApproval(
            "tool",
            `Read ${files.length} file(s)`,
            { tool: "read_file", files: files.map(f => f.path) }
        )

        if (!approved) {
            callbacks.pushToolResult("<error>User denied file read</error>")
            return
        }

        // 2. ê° íŒŒì¼ ì½ê¸°
        const results: string[] = []

        for (const file of files) {
            try {
                // RooIgnore ì²´í¬
                const isIgnored = await task.rooIgnoreController?.isIgnored(file.path)
                if (isIgnored) {
                    results.push(`<file path="${file.path}"><error>File is ignored</error></file>`)
                    continue
                }

                // íŒŒì¼ ì½ê¸°
                const content = await fs.readFile(file.path, "utf-8")

                // ì¤„ ë²”ìœ„ ì²˜ë¦¬
                let lines = content.split("\n")
                if (file.start_line || file.end_line) {
                    const start = (file.start_line || 1) - 1
                    const end = file.end_line || lines.length
                    lines = lines.slice(start, end)
                }

                results.push(`<file path="${file.path}">\n${lines.join("\n")}\n</file>`)

                // ì»¨í…ìŠ¤íŠ¸ ì¶”ì 
                task.fileContextTracker.trackFile(file.path)

            } catch (error) {
                results.push(`<file path="${file.path}"><error>${error.message}</error></file>`)
            }
        }

        // 3. ê²°ê³¼ ë°˜í™˜
        callbacks.pushToolResult(results.join("\n"))
    }

    /**
     * ìŠ¤íŠ¸ë¦¬ë° ë¶€ë¶„ ë©”ì‹œì§€ ì²˜ë¦¬
     */
    async handlePartial(task: Task, block: ToolUse<"read_file">): Promise<void> {
        // UIì— ì§„í–‰ ìƒí™© í‘œì‹œ
        const path = block.params.path || "..."
        await task.say("tool_progress", `Reading file: ${path}`)
    }
}
```

### ë„êµ¬ ë“±ë¡ ë° ì¡°íšŒ

```typescript
// ê°œë…ì  ë„êµ¬ ë ˆì§€ìŠ¤íŠ¸ë¦¬

const toolRegistry = new Map<ToolName, BaseTool<any>>([
    ["read_file", new ReadFileTool()],
    ["write_to_file", new WriteToFileTool()],
    ["execute_command", new ExecuteCommandTool()],
    ["browser_action", new BrowserActionTool()],
    ["use_mcp_tool", new UseMcpToolTool()],
    // ... ë” ë§ì€ ë„êµ¬
])

function getTool<TName extends ToolName>(name: TName): BaseTool<TName> {
    const tool = toolRegistry.get(name)
    if (!tool) {
        throw new Error(`Unknown tool: ${name}`)
    }
    return tool as BaseTool<TName>
}
```

---

## 5. ê¶Œí•œ ë° ìŠ¹ì¸ ì‹œìŠ¤í…œ

### ëª¨ë“œë³„ ë„êµ¬ í•„í„°ë§

```typescript
// ëª¨ë“œ ì •ì˜ì—ì„œ ë„êµ¬ ê·¸ë£¹ ì§€ì •

interface ModeDefinition {
    slug: string
    name: string
    roleDefinition: string
    groups: (ToolGroup | [ToolGroup, GroupOptions])[]
    customInstructions?: string
}

interface GroupOptions {
    fileRegex?: string  // íŒŒì¼ íŒ¨í„´ í•„í„°
}

// ì˜ˆì‹œ: í…ŒìŠ¤íŠ¸ ëª¨ë“œ
const testMode: ModeDefinition = {
    slug: "test",
    name: "ğŸ§ª Test",
    roleDefinition: "You are a testing specialist...",
    groups: [
        "read",  // ì½ê¸° ì „ìš© í—ˆìš©
        ["edit", { fileRegex: "(__tests__/.*|.*\\.test\\.ts$)" }]  // í…ŒìŠ¤íŠ¸ íŒŒì¼ë§Œ í¸ì§‘
    ]
}
```

### ë„êµ¬ ì‚¬ìš© ê°€ëŠ¥ ì—¬ë¶€ í™•ì¸

```typescript
// ê°œë…ì  êµ¬í˜„

function isToolAllowedInMode(
    toolName: ToolName,
    mode: ModeDefinition,
    filePath?: string
): boolean {
    const toolGroup = getToolGroup(toolName)

    for (const group of mode.groups) {
        if (Array.isArray(group)) {
            const [groupName, options] = group
            if (groupName === toolGroup) {
                // íŒŒì¼ íŒ¨í„´ ì²´í¬
                if (options.fileRegex && filePath) {
                    const regex = new RegExp(options.fileRegex)
                    return regex.test(filePath)
                }
                return true
            }
        } else {
            if (group === toolGroup) {
                return true
            }
        }
    }

    return false
}
```

### ìŠ¹ì¸ íë¦„

```mermaid
flowchart TD
    subgraph "Auto Approval Check"
        A[ë„êµ¬ í˜¸ì¶œ]
        B{ëª¨ë“œì—ì„œ í—ˆìš©?}
        B -->|No| C[ê±°ë¶€]
        B -->|Yes| D{ìë™ ìŠ¹ì¸ ì„¤ì •?}
    end

    subgraph "Category Check"
        D -->|Yes| E{ë„êµ¬ ì¹´í…Œê³ ë¦¬}
        E -->|read| F{alwaysAllowReadOnly?}
        E -->|write| G{alwaysAllowWrite?}
        E -->|execute| H{alwaysAllowExecute?}
        E -->|mcp| I{alwaysAllowMcp?}
    end

    subgraph "Additional Checks"
        G -->|Yes| J{ë³´í˜¸ëœ íŒŒì¼?}
        J -->|No| K[ìŠ¹ì¸]
        J -->|Yes| L[ì‚¬ìš©ì í™•ì¸]

        H -->|Yes| M{í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸?}
        M -->|Yes| K
        M -->|No| N{ë¸”ë™ë¦¬ìŠ¤íŠ¸?}
        N -->|Yes| C
        N -->|No| L

        I -->|Yes| O{ë„êµ¬ ìë™ìŠ¹ì¸?}
        O -->|Yes| K
        O -->|No| L
    end

    D -->|No| L
    F -->|Yes| K
    F -->|No| L
```

---

## 6. Jupyter ì ìš© ê°€ì´ë“œ

### BaseTool â†’ JupyterTool

```python
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import Generic, TypeVar, Dict, Any, Optional
from enum import Enum

class ToolCategory(Enum):
    READ = "read"
    WRITE = "write"
    EXECUTE = "execute"
    DISPLAY = "display"

TParams = TypeVar("TParams")

@dataclass
class ToolCallbacks:
    """ë„êµ¬ ì‹¤í–‰ ì½œë°±"""
    ask_approval: callable
    handle_error: callable
    push_result: callable
    kernel: 'KernelClient'

class JupyterTool(ABC, Generic[TParams]):
    """Jupyter ë„êµ¬ ê¸°ë³¸ í´ë˜ìŠ¤"""

    @property
    @abstractmethod
    def name(self) -> str:
        """ë„êµ¬ ì´ë¦„"""
        pass

    @property
    @abstractmethod
    def category(self) -> ToolCategory:
        """ë„êµ¬ ì¹´í…Œê³ ë¦¬"""
        pass

    @property
    @abstractmethod
    def description(self) -> str:
        """ë„êµ¬ ì„¤ëª… (LLMìš©)"""
        pass

    @abstractmethod
    def parse_params(self, raw_params: Dict[str, Any]) -> TParams:
        """íŒŒë¼ë¯¸í„° íŒŒì‹±"""
        pass

    @abstractmethod
    async def execute(
        self,
        params: TParams,
        context: 'ExecutionContext',
        callbacks: ToolCallbacks
    ) -> None:
        """ë„êµ¬ ì‹¤í–‰"""
        pass

    async def handle_partial(
        self,
        context: 'ExecutionContext',
        partial_params: Dict[str, Any]
    ) -> None:
        """ìŠ¤íŠ¸ë¦¬ë° ë¶€ë¶„ ë©”ì‹œì§€ ì²˜ë¦¬ (ì„ íƒì )"""
        pass

    async def handle(
        self,
        context: 'ExecutionContext',
        params: Dict[str, Any],
        callbacks: ToolCallbacks,
        is_partial: bool = False
    ) -> None:
        """ë©”ì¸ ì§„ì…ì """
        if is_partial:
            await self.handle_partial(context, params)
            return

        try:
            typed_params = self.parse_params(params)
        except Exception as e:
            await callbacks.handle_error(f"parsing {self.name} args", e)
            callbacks.push_result(f"<error>Failed to parse parameters: {e}</error>")
            return

        await self.execute(typed_params, context, callbacks)
```

### êµ¬ì²´ì ì¸ ë„êµ¬ êµ¬í˜„: ExecuteCodeTool

```python
from dataclasses import dataclass
from typing import Optional
import json

@dataclass
class ExecuteCodeParams:
    code: str
    language: str = "python"
    cell_id: Optional[str] = None

class ExecuteCodeTool(JupyterTool[ExecuteCodeParams]):
    """ì½”ë“œ ì‹¤í–‰ ë„êµ¬"""

    @property
    def name(self) -> str:
        return "execute_code"

    @property
    def category(self) -> ToolCategory:
        return ToolCategory.EXECUTE

    @property
    def description(self) -> str:
        return """Execute code in the Jupyter kernel.

Parameters:
- code (required): The code to execute
- language (optional): Programming language (default: python)
- cell_id (optional): Cell ID for tracking

Example:
{
    "code": "print('Hello, World!')",
    "language": "python"
}"""

    def parse_params(self, raw_params: Dict[str, Any]) -> ExecuteCodeParams:
        if "code" not in raw_params:
            raise ValueError("Missing required parameter: code")

        return ExecuteCodeParams(
            code=raw_params["code"],
            language=raw_params.get("language", "python"),
            cell_id=raw_params.get("cell_id")
        )

    async def execute(
        self,
        params: ExecuteCodeParams,
        context: 'ExecutionContext',
        callbacks: ToolCallbacks
    ) -> None:
        # 1. ìŠ¹ì¸ í™•ì¸
        approved = await callbacks.ask_approval(
            "execute_code",
            f"Execute {params.language} code:\n```{params.language}\n{params.code}\n```"
        )

        if not approved:
            callbacks.push_result("<error>User denied code execution</error>")
            return

        # 2. ì»¤ë„ì—ì„œ ì½”ë“œ ì‹¤í–‰
        try:
            result = await callbacks.kernel.execute(
                params.code,
                cell_id=params.cell_id
            )

            # 3. ê²°ê³¼ í¬ë§·íŒ…
            output_parts = []

            # í‘œì¤€ ì¶œë ¥
            if result.stdout:
                output_parts.append(f"<stdout>{result.stdout}</stdout>")

            # í‘œì¤€ ì—ëŸ¬
            if result.stderr:
                output_parts.append(f"<stderr>{result.stderr}</stderr>")

            # ì‹¤í–‰ ê²°ê³¼ (ë§ˆì§€ë§‰ í‘œí˜„ì‹)
            if result.result is not None:
                output_parts.append(f"<result>{result.result}</result>")

            # ë””ìŠ¤í”Œë ˆì´ ì¶œë ¥ (ì´ë¯¸ì§€, HTML ë“±)
            for display in result.displays:
                output_parts.append(
                    f"<display type=\"{display.mime_type}\">{display.data}</display>"
                )

            # ì—ëŸ¬
            if result.error:
                output_parts.append(
                    f"<error>\n{result.error.traceback}\n</error>"
                )

            callbacks.push_result("\n".join(output_parts))

        except Exception as e:
            await callbacks.handle_error("executing code", e)
            callbacks.push_result(f"<error>Execution failed: {e}</error>")

    async def handle_partial(
        self,
        context: 'ExecutionContext',
        partial_params: Dict[str, Any]
    ) -> None:
        # ì½”ë“œê°€ ìŠ¤íŠ¸ë¦¬ë°ë˜ëŠ” ë™ì•ˆ UIì— í‘œì‹œ
        if "code" in partial_params:
            code_preview = partial_params["code"][:100]
            await context.show_progress(f"Preparing to execute: {code_preview}...")
```

### Jupyter ì „ìš© ë„êµ¬ë“¤

```python
# ë³€ìˆ˜ ê²€ì‚¬ ë„êµ¬
class InspectVariablesTool(JupyterTool[InspectVariablesParams]):
    """í˜„ì¬ ì»¤ë„ì˜ ë³€ìˆ˜ ê²€ì‚¬"""

    @property
    def name(self) -> str:
        return "inspect_variables"

    async def execute(
        self,
        params: InspectVariablesParams,
        context: 'ExecutionContext',
        callbacks: ToolCallbacks
    ) -> None:
        # ì»¤ë„ì—ì„œ ë³€ìˆ˜ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        variables = await callbacks.kernel.get_variables(
            filter_pattern=params.filter,
            include_types=params.types
        )

        result = "<variables>\n"
        for var in variables:
            result += f"  <var name=\"{var.name}\" type=\"{var.type}\" size=\"{var.size}\">\n"
            result += f"    {var.preview}\n"
            result += f"  </var>\n"
        result += "</variables>"

        callbacks.push_result(result)


# ì‹œê°í™” ë„êµ¬
class PlotChartTool(JupyterTool[PlotChartParams]):
    """ì°¨íŠ¸ ìƒì„± ë° í‘œì‹œ"""

    @property
    def name(self) -> str:
        return "plot_chart"

    async def execute(
        self,
        params: PlotChartParams,
        context: 'ExecutionContext',
        callbacks: ToolCallbacks
    ) -> None:
        # ì°¨íŠ¸ ìƒì„± ì½”ë“œ ì‹¤í–‰
        plot_code = self.generate_plot_code(params)

        result = await callbacks.kernel.execute(plot_code)

        if result.displays:
            # ì´ë¯¸ì§€ ë°ì´í„° ë°˜í™˜
            for display in result.displays:
                if display.mime_type.startswith("image/"):
                    callbacks.push_result(
                        f"<chart type=\"{params.chart_type}\" "
                        f"format=\"{display.mime_type}\">\n"
                        f"{display.data}\n"
                        f"</chart>"
                    )
                    return

        callbacks.push_result("<error>Failed to generate chart</error>")


# ì…€ ê´€ë¦¬ ë„êµ¬
class ManageCellTool(JupyterTool[ManageCellParams]):
    """ë…¸íŠ¸ë¶ ì…€ ê´€ë¦¬"""

    @property
    def name(self) -> str:
        return "manage_cell"

    async def execute(
        self,
        params: ManageCellParams,
        context: 'ExecutionContext',
        callbacks: ToolCallbacks
    ) -> None:
        notebook = context.notebook

        match params.action:
            case "create":
                cell_id = notebook.create_cell(
                    cell_type=params.cell_type,
                    content=params.content,
                    position=params.position
                )
                callbacks.push_result(f"<cell id=\"{cell_id}\" action=\"created\"/>")

            case "delete":
                notebook.delete_cell(params.cell_id)
                callbacks.push_result(f"<cell id=\"{params.cell_id}\" action=\"deleted\"/>")

            case "move":
                notebook.move_cell(params.cell_id, params.position)
                callbacks.push_result(f"<cell id=\"{params.cell_id}\" action=\"moved\"/>")

            case "update":
                notebook.update_cell(params.cell_id, params.content)
                callbacks.push_result(f"<cell id=\"{params.cell_id}\" action=\"updated\"/>")
```

### ë„êµ¬ ë ˆì§€ìŠ¤íŠ¸ë¦¬

```python
from typing import Dict, Type

class ToolRegistry:
    """Jupyter ë„êµ¬ ë ˆì§€ìŠ¤íŠ¸ë¦¬"""

    def __init__(self):
        self._tools: Dict[str, JupyterTool] = {}
        self._register_default_tools()

    def _register_default_tools(self):
        """ê¸°ë³¸ ë„êµ¬ ë“±ë¡"""
        default_tools = [
            ExecuteCodeTool(),
            InspectVariablesTool(),
            PlotChartTool(),
            ManageCellTool(),
            ReadFileTool(),
            WriteFileTool(),
            SearchFilesTool(),
        ]

        for tool in default_tools:
            self.register(tool)

    def register(self, tool: JupyterTool):
        """ë„êµ¬ ë“±ë¡"""
        self._tools[tool.name] = tool

    def get(self, name: str) -> JupyterTool:
        """ë„êµ¬ ì¡°íšŒ"""
        if name not in self._tools:
            raise ValueError(f"Unknown tool: {name}")
        return self._tools[name]

    def get_all(self) -> list[JupyterTool]:
        """ëª¨ë“  ë„êµ¬ ë°˜í™˜"""
        return list(self._tools.values())

    def get_by_category(self, category: ToolCategory) -> list[JupyterTool]:
        """ì¹´í…Œê³ ë¦¬ë³„ ë„êµ¬ ë°˜í™˜"""
        return [t for t in self._tools.values() if t.category == category]

    def get_tool_descriptions(self) -> str:
        """LLMìš© ë„êµ¬ ì„¤ëª… ìƒì„±"""
        descriptions = []
        for tool in self._tools.values():
            descriptions.append(f"## {tool.name}\n{tool.description}\n")
        return "\n".join(descriptions)
```

### Jupyter Magic Command í†µí•©

```python
from IPython.core.magic import register_line_magic, register_cell_magic

class JupyterMagicBridge:
    """Jupyter Magic Commandë¥¼ ë„êµ¬ë¡œ ë…¸ì¶œ"""

    def __init__(self, registry: ToolRegistry):
        self.registry = registry

    def create_magic_tool(self, magic_name: str) -> JupyterTool:
        """Magic Commandë¥¼ ë„êµ¬ë¡œ ë˜í•‘"""

        @dataclass
        class MagicParams:
            line: str = ""
            cell: str = ""

        class MagicTool(JupyterTool[MagicParams]):
            @property
            def name(self) -> str:
                return f"magic_{magic_name}"

            @property
            def category(self) -> ToolCategory:
                return ToolCategory.EXECUTE

            @property
            def description(self) -> str:
                return f"Execute Jupyter magic command: %{magic_name}"

            def parse_params(self, raw_params: Dict[str, Any]) -> MagicParams:
                return MagicParams(
                    line=raw_params.get("line", ""),
                    cell=raw_params.get("cell", "")
                )

            async def execute(
                self,
                params: MagicParams,
                context: 'ExecutionContext',
                callbacks: ToolCallbacks
            ) -> None:
                if params.cell:
                    # Cell magic
                    code = f"%%{magic_name} {params.line}\n{params.cell}"
                else:
                    # Line magic
                    code = f"%{magic_name} {params.line}"

                result = await callbacks.kernel.execute(code)
                callbacks.push_result(str(result))

        return MagicTool()

    def register_common_magics(self):
        """ì¼ë°˜ì ì¸ magic commandë“¤ì„ ë„êµ¬ë¡œ ë“±ë¡"""
        common_magics = [
            "timeit",
            "debug",
            "prun",
            "load",
            "save",
            "matplotlib",
            "pip",
            "conda",
        ]

        for magic in common_magics:
            tool = self.create_magic_tool(magic)
            self.registry.register(tool)
```

---

## ë‹¤ìŒ ë¬¸ì„œ

- [04-MCP-í†µí•©.md](./04-MCP-í†µí•©.md) - MCP (Model Context Protocol) í†µí•©
