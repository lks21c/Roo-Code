# 05. 프롬프트 관리 시스템

## 개요

Roo-Code의 프롬프트 시스템은 모듈식 섹션 기반 아키텍처를 사용하여 동적이고 컨텍스트 인식적인 시스템 프롬프트를 생성합니다. 이 시스템은 모드, 도구, MCP 서버, 커스텀 지시사항 등을 유연하게 조합합니다.

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                       System Prompt Architecture                             │
└─────────────────────────────────────────────────────────────────────────────┘

                        ┌─────────────────────┐
                        │   SYSTEM_PROMPT()   │
                        │    Entry Point      │
                        └──────────┬──────────┘
                                   │
        ┌──────────────────────────┼──────────────────────────┐
        │                          │                          │
        ▼                          ▼                          ▼
┌───────────────┐        ┌───────────────┐        ┌───────────────┐
│ File-based    │        │  generatePrompt│        │  Mode Config  │
│ Custom Prompt │        │  (Sections)    │        │  Selection    │
│ (.roo/)       │        │                │        │               │
└───────────────┘        └───────┬────────┘        └───────────────┘
                                 │
        ┌────────────────────────┼────────────────────────┐
        │           │           │           │            │
        ▼           ▼           ▼           ▼            ▼
   ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐ ┌─────────┐
   │  Role   │ │ Tools   │ │  MCP    │ │ Rules   │ │ Custom  │
   │Definition│ │ Catalog │ │ Servers │ │         │ │ Instrs  │
   └─────────┘ └─────────┘ └─────────┘ └─────────┘ └─────────┘
```

---

## 시스템 프롬프트 생성 흐름

### 진입점: SYSTEM_PROMPT 함수

```typescript
// src/core/prompts/system.ts

export const SYSTEM_PROMPT = async (
  context: vscode.ExtensionContext,
  cwd: string,
  supportsComputerUse: boolean,
  mcpHub?: McpHub,
  diffStrategy?: DiffStrategy,
  browserViewportSize?: string,
  mode: Mode = defaultModeSlug,
  customModePrompts?: CustomModePrompts,
  customModes?: ModeConfig[],
  globalCustomInstructions?: string,
  diffEnabled?: boolean,
  experiments?: Record<string, boolean>,
  enableMcpServerCreation?: boolean,
  language?: string,
  rooIgnoreInstructions?: string,
  partialReadsEnabled?: boolean,
  settings?: SystemPromptSettings,
  todoList?: TodoItem[],
  modelId?: string,
): Promise<string> => {
  // 1. 프롬프트 변수 준비
  const variablesForPrompt: PromptVariables = {
    workspace: cwd,
    mode: mode,
    language: language ?? formatLanguage(vscode.env.language),
    shell: vscode.env.shell,
    operatingSystem: os.type(),
  }

  // 2. 파일 기반 커스텀 프롬프트 확인
  const fileCustomSystemPrompt = await loadSystemPromptFile(cwd, mode, variablesForPrompt)

  // 3. 프롬프트 컴포넌트 가져오기
  const promptComponent = getPromptComponent(customModePrompts, mode)

  // 4. 현재 모드 설정 확인
  const currentMode = getModeBySlug(mode, customModes) || modes.find((m) => m.slug === mode) || modes[0]

  // 5. 파일 기반 프롬프트가 있으면 사용
  if (fileCustomSystemPrompt) {
    const { roleDefinition, baseInstructions } = getModeSelection(mode, promptComponent, customModes)
    const customInstructions = await addCustomInstructions(...)
    return `${roleDefinition}\n\n${fileCustomSystemPrompt}\n\n${customInstructions}`
  }

  // 6. 표준 프롬프트 생성
  return generatePrompt(context, cwd, supportsComputerUse, currentMode.slug, ...)
}
```

### 프롬프트 생성 함수

```typescript
async function generatePrompt(
  context: vscode.ExtensionContext,
  cwd: string,
  supportsComputerUse: boolean,
  mode: Mode,
  mcpHub?: McpHub,
  diffStrategy?: DiffStrategy,
  // ... 기타 매개변수
): Promise<string> {
  // 1. 프로토콜 결정 (XML vs Native)
  const effectiveProtocol = getEffectiveProtocol(settings?.toolProtocol)

  // 2. MCP 포함 여부 결정
  const modeConfig = getModeBySlug(mode, customModeConfigs)
  const hasMcpGroup = modeConfig.groups.some(g => getGroupName(g) === "mcp")
  const hasMcpServers = mcpHub && mcpHub.getServers().length > 0
  const shouldIncludeMcp = hasMcpGroup && hasMcpServers

  // 3. 병렬로 섹션 생성
  const [modesSection, mcpServersSection] = await Promise.all([
    getModesSection(context),
    shouldIncludeMcp ? getMcpServersSection(mcpHub, ...) : Promise.resolve(""),
  ])

  // 4. 도구 카탈로그 (XML 프로토콜만)
  const toolsCatalog = isNativeProtocol(effectiveProtocol)
    ? ""
    : `\n\n${getToolDescriptionsForMode(mode, cwd, ...)}`

  // 5. 전체 프롬프트 조립
  const basePrompt = `${roleDefinition}

${markdownFormattingSection()}

${getSharedToolUseSection(effectiveProtocol)}${toolsCatalog}

${getToolUseGuidelinesSection(effectiveProtocol)}

${mcpServersSection}

${getCapabilitiesSection(cwd, mcpHub)}

${modesSection}

${getRulesSection(cwd, settings)}

${getSystemInfoSection(cwd)}

${getObjectiveSection()}

${await addCustomInstructions(baseInstructions, globalCustomInstructions, cwd, mode, ...)}`

  return basePrompt
}
```

---

## 섹션 기반 모듈 아키텍처

### 섹션 인덱스

```typescript
// src/core/prompts/sections/index.ts

export { getRulesSection } from "./rules"
export { getSystemInfoSection } from "./system-info"
export { getObjectiveSection } from "./objective"
export { addCustomInstructions } from "./custom-instructions"
export { getSharedToolUseSection } from "./tool-use"
export { getMcpServersSection } from "./mcp-servers"
export { getToolUseGuidelinesSection } from "./tool-use-guidelines"
export { getCapabilitiesSection } from "./capabilities"
export { getModesSection } from "./modes"
export { markdownFormattingSection } from "./markdown-formatting"
```

### 프롬프트 구조 다이어그램

```
┌─────────────────────────────────────────────────────────────────┐
│                     System Prompt Structure                      │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  1. ROLE DEFINITION                                              │
│  - Mode-specific role and responsibilities                       │
│  - Can be customized per mode                                    │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  2. MARKDOWN FORMATTING                                          │
│  - Response format instructions                                  │
│  - Code block handling                                           │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  3. TOOL USE (Protocol-Dependent)                                │
│  - XML: Tool descriptions with XML tags                          │
│  - Native: Tool available as function calls                      │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  4. TOOL USE GUIDELINES                                          │
│  - How to use tools correctly                                    │
│  - Error handling patterns                                       │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  5. MCP SERVERS (If Enabled)                                     │
│  - Connected server list                                         │
│  - Available tools and resources                                 │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  6. CAPABILITIES                                                 │
│  - What the agent can do                                         │
│  - Environment-specific features                                 │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  7. MODES                                                        │
│  - Available modes description                                   │
│  - Mode switching guidance                                       │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  8. RULES                                                        │
│  - Project base directory                                        │
│  - Tool usage constraints                                        │
│  - Behavioral guidelines                                         │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  9. SYSTEM INFORMATION                                           │
│  - OS, shell, environment details                                │
│  - Working directory info                                        │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  10. OBJECTIVE                                                   │
│  - Task accomplishment focus                                     │
│  - Success criteria                                              │
└─────────────────────────────────────────────────────────────────┘
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│  11. CUSTOM INSTRUCTIONS                                         │
│  - Language preference                                           │
│  - Global instructions                                           │
│  - Mode-specific instructions                                    │
│  - Rule files (.roorules, AGENTS.md)                             │
└─────────────────────────────────────────────────────────────────┘
```

---

## 모드 시스템

### 모드 설정 구조

```typescript
// @roo-code/types에서 정의

interface ModeConfig {
  slug: string              // 모드 식별자 (예: "code", "architect", "ask")
  name: string              // 표시 이름
  description: string       // 모드 설명
  roleDefinition: string    // AI 역할 정의
  customInstructions?: string  // 모드별 추가 지시사항
  groups: GroupEntry[]      // 도구 그룹 목록
  whenToUse?: string        // 언제 사용해야 하는지
  source?: "builtin" | "custom"  // 출처
}

// 그룹 항목은 문자열 또는 옵션이 포함된 배열
type GroupEntry = ToolGroup | [ToolGroup, GroupOptions]

interface GroupOptions {
  fileRegex?: string        // 파일 패턴 제한
  description?: string      // 제한 설명
}
```

### 기본 모드 (DEFAULT_MODES)

```typescript
export const DEFAULT_MODES: readonly ModeConfig[] = [
  {
    slug: "code",
    name: "Code",
    description: "Default coding mode",
    roleDefinition: "You are Roo, a highly skilled software engineer...",
    groups: ["read", "edit", "browser", "command", "mcp"],
    whenToUse: "For general coding tasks and file modifications",
    source: "builtin",
  },
  {
    slug: "architect",
    name: "Architect",
    description: "Planning and design mode",
    roleDefinition: "You are Roo, a software architect...",
    groups: [
      "read",
      ["edit", { fileRegex: "\\.md$", description: "Markdown files only" }],
      "browser",
      "mcp"
    ],
    whenToUse: "For system design and architectural planning",
    source: "builtin",
  },
  {
    slug: "ask",
    name: "Ask",
    description: "Question answering mode",
    roleDefinition: "You are Roo, a knowledgeable assistant...",
    groups: ["read", "browser", "mcp"],
    whenToUse: "For answering questions without making changes",
    source: "builtin",
  },
  // ... 기타 모드
]
```

### 모드 선택 로직

```typescript
// src/shared/modes.ts

export function getModeSelection(
  mode: string,
  promptComponent?: PromptComponent,
  customModes?: ModeConfig[]
) {
  const customMode = findModeBySlug(mode, customModes)
  const builtInMode = findModeBySlug(mode, modes)

  // 커스텀 모드가 있으면 완전히 사용
  if (customMode) {
    return {
      roleDefinition: customMode.roleDefinition || "",
      baseInstructions: customMode.customInstructions || "",
      description: customMode.description || "",
    }
  }

  // 기본 모드에 promptComponent 병합
  const baseMode = builtInMode || modes[0]

  return {
    roleDefinition: promptComponent?.roleDefinition || baseMode.roleDefinition || "",
    baseInstructions: promptComponent?.customInstructions || baseMode.customInstructions || "",
    description: baseMode.description || "",
  }
}
```

---

## 도구 필터링 시스템

### 모드별 도구 설명 생성

```typescript
// src/core/prompts/tools/index.ts

// 도구 이름 → 설명 함수 매핑
const toolDescriptionMap: Record<string, (args: ToolArgs) => string | undefined> = {
  execute_command: (args) => getExecuteCommandDescription(args),
  read_file: (args) => {
    // 모델에 따라 단순/복잡 버전 선택
    const modelId = args.settings?.modelId
    if (modelId && shouldUseSingleFileRead(modelId)) {
      return getSimpleReadFileDescription(args)
    }
    return getReadFileDescription(args)
  },
  write_to_file: (args) => getWriteToFileDescription(args),
  search_files: (args) => getSearchFilesDescription(args),
  apply_diff: (args) => args.diffStrategy?.getToolDescription({ cwd: args.cwd }),
  use_mcp_tool: (args) => getUseMcpToolDescription(args),
  // ... 기타 도구들
}

export function getToolDescriptionsForMode(
  mode: Mode,
  cwd: string,
  supportsComputerUse: boolean,
  codeIndexManager?: CodeIndexManager,
  diffStrategy?: DiffStrategy,
  browserViewportSize?: string,
  mcpHub?: McpHub,
  customModes?: ModeConfig[],
  experiments?: Record<string, boolean>,
  partialReadsEnabled?: boolean,
  settings?: Record<string, any>,
  enableMcpServerCreation?: boolean,
  modelId?: string,
): string {
  const config = getModeConfig(mode, customModes)
  const args: ToolArgs = { cwd, supportsComputerUse, diffStrategy, ... }

  const tools = new Set<string>()

  // 1. 모드의 그룹에서 도구 추가
  config.groups.forEach((groupEntry) => {
    const groupName = getGroupName(groupEntry)
    const toolGroup = TOOL_GROUPS[groupName]
    if (toolGroup) {
      toolGroup.tools.forEach((tool) => {
        if (isToolAllowedForMode(tool, mode, customModes, undefined, undefined, experiments)) {
          tools.add(tool)
        }
      })
    }
  })

  // 2. 항상 사용 가능한 도구 추가
  ALWAYS_AVAILABLE_TOOLS.forEach((tool) => tools.add(tool))

  // 3. 조건부 도구 제외
  if (!codeIndexManager?.isFeatureEnabled) {
    tools.delete("codebase_search")
  }

  if (settings?.todoListEnabled === false) {
    tools.delete("update_todo_list")
  }

  if (!experiments?.imageGeneration) {
    tools.delete("generate_image")
  }

  // 4. 도구 설명 생성
  const descriptions = Array.from(tools).map((toolName) => {
    const descriptionFn = toolDescriptionMap[toolName]
    return descriptionFn ? descriptionFn(args) : undefined
  })

  return `# Tools\n\n${descriptions.filter(Boolean).join("\n\n")}`
}
```

### 도구 허용 검사

```typescript
// src/shared/modes.ts

export function isToolAllowedForMode(
  tool: string,
  modeSlug: string,
  customModes: ModeConfig[],
  toolRequirements?: Record<string, boolean>,
  toolParams?: Record<string, any>,
  experiments?: Record<string, boolean>,
  includedTools?: string[],
): boolean {
  // 1. 항상 허용되는 도구 확인
  if (ALWAYS_AVAILABLE_TOOLS.includes(tool as any)) {
    return true
  }

  // 2. 동적 MCP 도구 확인 (mcp_serverName_toolName)
  const isDynamicMcpTool = tool.startsWith("mcp_")

  // 3. 실험적 기능 확인
  if (experiments && Object.values(EXPERIMENT_IDS).includes(tool as ExperimentId)) {
    if (!experiments[tool]) {
      return false
    }
  }

  // 4. 도구 요구사항 확인
  if (toolRequirements && typeof toolRequirements === "object") {
    if (tool in toolRequirements && !toolRequirements[tool]) {
      return false
    }
  }

  // 5. 모드 설정 확인
  const mode = getModeBySlug(modeSlug, customModes)
  if (!mode) return false

  // 6. 그룹 기반 도구 허용 확인
  const allowedTools = getToolsForMode(mode.groups)
  if (!allowedTools.includes(tool) && !isDynamicMcpTool) {
    return false
  }

  // 7. 파일 제한 검사 (fileRegex)
  // ... 파일 경로 기반 제한 로직

  return true
}
```

---

## 커스텀 지시사항 시스템

### 지시사항 로딩 순서

```
┌─────────────────────────────────────────────────────────────────┐
│              Custom Instructions Loading Order                   │
└─────────────────────────────────────────────────────────────────┘

1. Language Preference (언어 설정)
   └─ "You should always speak in Korean..."

2. Global Instructions (전역 지시사항)
   └─ VSCode 설정에서 정의

3. Mode-specific Instructions (모드별 지시사항)
   └─ 모드 설정의 customInstructions

4. Rules (규칙 파일)
   ├─ Mode-specific rules (.roo/rules-{mode}/)
   ├─ AGENTS.md / AGENT.md
   ├─ Generic rules (.roo/rules/)
   └─ Legacy files (.roorules, .clinerules)
```

### 커스텀 지시사항 추가 함수

```typescript
// src/core/prompts/sections/custom-instructions.ts

export async function addCustomInstructions(
  modeCustomInstructions: string,
  globalCustomInstructions: string,
  cwd: string,
  mode: string,
  options: {
    language?: string
    rooIgnoreInstructions?: string
    settings?: SystemPromptSettings
  } = {},
): Promise<string> {
  const sections = []

  // 1. 모드별 규칙 로드
  let modeRuleContent = ""
  if (mode) {
    const rooDirectories = getRooDirectoriesForCwd(cwd)

    // .roo/rules-{mode}/ 디렉토리 확인
    for (const rooDir of rooDirectories) {
      const modeRulesDir = path.join(rooDir, `rules-${mode}`)
      if (await directoryExists(modeRulesDir)) {
        const files = await readTextFilesFromDirectory(modeRulesDir)
        if (files.length > 0) {
          modeRuleContent = formatDirectoryContent(modeRulesDir, files)
        }
      }
    }

    // 레거시 파일 폴백
    if (!modeRuleContent) {
      modeRuleContent = await safeReadFile(path.join(cwd, `.roorules-${mode}`))
    }
  }

  // 2. 언어 설정 추가
  if (options.language) {
    const languageName = isLanguage(options.language) ? LANGUAGES[options.language] : options.language
    sections.push(
      `Language Preference:\nYou should always speak and think in the "${languageName}" language...`
    )
  }

  // 3. 전역 지시사항 추가
  if (globalCustomInstructions?.trim()) {
    sections.push(`Global Instructions:\n${globalCustomInstructions.trim()}`)
  }

  // 4. 모드별 지시사항 추가
  if (modeCustomInstructions?.trim()) {
    sections.push(`Mode-specific Instructions:\n${modeCustomInstructions.trim()}`)
  }

  // 5. 규칙 추가
  const rules = []

  // 모드별 규칙
  if (modeRuleContent?.trim()) {
    rules.push(modeRuleContent.trim())
  }

  // rooIgnore 지시사항
  if (options.rooIgnoreInstructions) {
    rules.push(options.rooIgnoreInstructions)
  }

  // AGENTS.md (Agent Rules Standard)
  if (options.settings?.useAgentRules !== false) {
    const agentRulesContent = await loadAgentRulesFile(cwd)
    if (agentRulesContent?.trim()) {
      rules.push(agentRulesContent.trim())
    }
  }

  // 일반 규칙 파일
  const genericRuleContent = await loadRuleFiles(cwd)
  if (genericRuleContent?.trim()) {
    rules.push(genericRuleContent.trim())
  }

  if (rules.length > 0) {
    sections.push(`Rules:\n\n${rules.join("\n\n")}`)
  }

  // 6. 최종 포맷팅
  const joinedSections = sections.join("\n\n")

  return joinedSections
    ? `
====

USER'S CUSTOM INSTRUCTIONS

The following additional instructions are provided by the user...

${joinedSections}
`
    : ""
}
```

### 규칙 파일 로딩

```typescript
// src/core/prompts/sections/custom-instructions.ts

export async function loadRuleFiles(cwd: string): Promise<string> {
  const rules: string[] = []
  const rooDirectories = getRooDirectoriesForCwd(cwd)

  // .roo/rules/ 디렉토리 확인 (글로벌 → 프로젝트 순서)
  for (const rooDir of rooDirectories) {
    const rulesDir = path.join(rooDir, "rules")
    if (await directoryExists(rulesDir)) {
      const files = await readTextFilesFromDirectory(rulesDir)
      if (files.length > 0) {
        const content = formatDirectoryContent(rulesDir, files)
        rules.push(content)
      }
    }
  }

  if (rules.length > 0) {
    return "\n" + rules.join("\n\n")
  }

  // 레거시 파일 폴백
  const ruleFiles = [".roorules", ".clinerules"]
  for (const file of ruleFiles) {
    const content = await safeReadFile(path.join(cwd, file))
    if (content) {
      return `\n# Rules from ${file}:\n${content}\n`
    }
  }

  return ""
}

// AGENTS.md 로딩 (에이전트 표준 규칙)
async function loadAgentRulesFile(cwd: string): Promise<string> {
  const filenames = ["AGENTS.md", "AGENT.md"]

  for (const filename of filenames) {
    const content = await safeReadFile(path.join(cwd, filename))
    if (content) {
      return `# Agent Rules Standard (${filename}):\n${content}`
    }
  }
  return ""
}
```

---

## 규칙 섹션

### RULES 섹션 생성

```typescript
// src/core/prompts/sections/rules.ts

export function getRulesSection(cwd: string, settings?: SystemPromptSettings): string {
  const effectiveProtocol = getEffectiveProtocol(settings?.toolProtocol)

  return `====

RULES

- The project base directory is: ${cwd.toPosix()}
- All file paths must be relative to this directory.
- You cannot \`cd\` into a different directory to complete a task.
- Do not use the ~ character or $HOME to refer to the home directory.
- Before using the execute_command tool, you must first think about the SYSTEM INFORMATION context...
- Some modes have restrictions on which files they can edit.
- Be sure to consider the type of project when determining the appropriate structure...
- When making changes to code, always consider the context...
- Do not ask for more information than necessary.
- You are only allowed to ask the user questions using the ask_followup_question tool.
- When executing commands, if you don't see expected output, assume success...
- Your goal is to accomplish the user's task, NOT engage in conversation.
- NEVER end attempt_completion result with a question!
- You are STRICTLY FORBIDDEN from starting messages with "Great", "Certainly", "Okay", "Sure".
- At the end of each user message, you will receive environment_details...
- MCP operations should be used one at a time, similar to other tool usage.
- It is critical you wait for the user's response after each tool use...
${settings?.isStealthModel ? getVendorConfidentialitySection() : ""}`
}
```

---

## 이중 프로토콜 지원

### XML vs Native 프로토콜

```
┌─────────────────────────────────────────────────────────────────┐
│                Protocol-Dependent Sections                       │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  XML Protocol (Default)                                          │
├─────────────────────────────────────────────────────────────────┤
│  - Full tool descriptions in prompt                              │
│  - Tool usage via XML tags                                       │
│    <read_file>                                                   │
│      <path>src/file.ts</path>                                    │
│    </read_file>                                                  │
│  - MCP tools via use_mcp_tool                                    │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Native Protocol (Function Calling)                              │
├─────────────────────────────────────────────────────────────────┤
│  - Tool definitions as JSON Schema                               │
│  - Tool usage via function calls                                 │
│  - MCP tools as mcp_{server}_{tool}                              │
│  - Reduced prompt size (no descriptions in prompt)               │
└─────────────────────────────────────────────────────────────────┘
```

### 프로토콜별 분기 처리

```typescript
// 프로토콜 결정
const effectiveProtocol = getEffectiveProtocol(settings?.toolProtocol)

// XML 프로토콜에서만 도구 카탈로그 포함
const toolsCatalog = isNativeProtocol(effectiveProtocol)
  ? ""
  : `\n\n${getToolDescriptionsForMode(mode, cwd, ...)}`

// MCP 서버 섹션에서 도구 설명 포함 여부
const mcpServersSection = getMcpServersSection(
  mcpHub,
  diffStrategy,
  enableMcpServerCreation,
  !isNativeProtocol(effectiveProtocol)  // XML에서만 도구 설명 포함
)
```

---

## 환경 정보 동적 생성

### 시스템 정보 섹션

```typescript
// src/core/prompts/sections/system-info.ts

export function getSystemInfoSection(cwd: string): string {
  const homeDir = os.homedir()
  const cacheDir = getCacheDir()

  return `====

SYSTEM INFORMATION

Operating System: ${os.type()} ${os.release()}
Architecture: ${os.arch()}
Home Directory: ${homeDir}
Current Working Directory: ${cwd}
Default Shell: ${process.env.SHELL || process.env.COMSPEC || "unknown"}
Cache Directory: ${cacheDir}

Note: The above system information is provided automatically...`
}
```

### 프롬프트 변수 시스템

```typescript
// src/core/prompts/sections/custom-system-prompt.ts

export interface PromptVariables {
  workspace: string       // 작업 디렉토리
  mode: string            // 현재 모드
  language: string        // 언어 설정
  shell: string           // 셸 정보
  operatingSystem: string // OS 정보
}

// 변수 치환 함수
function replaceVariables(content: string, variables: PromptVariables): string {
  return content
    .replace(/\{\{workspace\}\}/g, variables.workspace)
    .replace(/\{\{mode\}\}/g, variables.mode)
    .replace(/\{\{language\}\}/g, variables.language)
    .replace(/\{\{shell\}\}/g, variables.shell)
    .replace(/\{\{operatingSystem\}\}/g, variables.operatingSystem)
}
```

---

## Jupyter 에이전트 적용 가이드

### 프롬프트 시스템 Python 구현

```python
# prompt_system.py - Jupyter 에이전트용 프롬프트 시스템

from dataclasses import dataclass, field
from typing import List, Dict, Optional, Callable, Any
from pathlib import Path
import os

@dataclass
class ModeConfig:
    """모드 설정"""
    slug: str
    name: str
    description: str
    role_definition: str
    custom_instructions: str = ""
    groups: List[str] = field(default_factory=list)
    when_to_use: str = ""
    source: str = "builtin"

@dataclass
class ToolArgs:
    """도구 인자 컨테이너"""
    cwd: str
    supports_code_execution: bool = True
    kernel_info: Optional[Dict] = None
    experiments: Dict[str, bool] = field(default_factory=dict)
    settings: Dict[str, Any] = field(default_factory=dict)

# 기본 모드 정의
DEFAULT_MODES: List[ModeConfig] = [
    ModeConfig(
        slug="code",
        name="Code",
        description="Jupyter 셀 실행 및 코드 작성 모드",
        role_definition="""You are a Jupyter notebook assistant skilled in data science,
machine learning, and scientific computing. You can execute code cells, create
visualizations, and help with data analysis.""",
        groups=["read", "execute", "visualization", "data"],
        when_to_use="일반적인 코딩 및 데이터 분석 작업",
    ),
    ModeConfig(
        slug="analysis",
        name="Analysis",
        description="데이터 분석 전문 모드",
        role_definition="""You are a data analyst assistant focused on exploratory
data analysis, statistical testing, and insight generation.""",
        groups=["read", "execute", "visualization", "statistics"],
        when_to_use="데이터 탐색 및 분석 작업",
    ),
    ModeConfig(
        slug="explain",
        name="Explain",
        description="코드 설명 모드",
        role_definition="""You are an educational assistant that explains code,
concepts, and results in a clear, approachable manner.""",
        groups=["read"],
        when_to_use="코드 설명 및 학습 지원",
    ),
]

class PromptSectionGenerator:
    """프롬프트 섹션 생성기"""

    def __init__(self, cwd: str, kernel_name: str = "python3"):
        self.cwd = cwd
        self.kernel_name = kernel_name

    def get_role_definition(self, mode: ModeConfig) -> str:
        """역할 정의 섹션"""
        return mode.role_definition

    def get_markdown_formatting_section(self) -> str:
        """마크다운 포맷팅 섹션"""
        return """
## Response Formatting

- Use markdown for all responses
- Code should be in fenced code blocks with language specification
- Use LaTeX for mathematical expressions
- Structure responses with headers for complex explanations
"""

    def get_rules_section(self) -> str:
        """규칙 섹션"""
        return f"""
====

RULES

- The notebook directory is: {self.cwd}
- Always use relative paths within the project
- Execute code cells one at a time and verify results
- Handle data loading errors gracefully
- Preserve notebook state between cells
- Clean up temporary files and large objects when done
- Use appropriate visualizations for data types
- Comment complex operations for clarity
"""

    def get_system_info_section(self) -> str:
        """시스템 정보 섹션"""
        import platform
        return f"""
====

SYSTEM INFORMATION

Operating System: {platform.system()} {platform.release()}
Python Version: {platform.python_version()}
Kernel: {self.kernel_name}
Working Directory: {self.cwd}
Home Directory: {Path.home()}
"""

    def get_capabilities_section(self, tools: List[str]) -> str:
        """기능 섹션"""
        capabilities = [
            "Execute Python code in Jupyter cells",
            "Create and display visualizations (matplotlib, plotly, etc.)",
            "Read and write files in the workspace",
            "Install packages via pip/conda",
            "Access kernel variables and state",
        ]

        return f"""
====

CAPABILITIES

You have access to a Jupyter kernel and can:

{chr(10).join(f'- {cap}' for cap in capabilities)}

Available tools: {', '.join(tools)}
"""

    def get_objective_section(self) -> str:
        """목표 섹션"""
        return """
====

OBJECTIVE

Accomplish the user's data science, analysis, or coding task efficiently.
Execute code to verify solutions and provide clear explanations of results.
"""

class JupyterPromptSystem:
    """Jupyter 에이전트 프롬프트 시스템"""

    def __init__(
        self,
        cwd: str,
        kernel_name: str = "python3",
        custom_modes: Optional[List[ModeConfig]] = None
    ):
        self.cwd = cwd
        self.kernel_name = kernel_name
        self.modes = {m.slug: m for m in (custom_modes or DEFAULT_MODES)}
        self.section_generator = PromptSectionGenerator(cwd, kernel_name)
        self.tool_descriptions: Dict[str, Callable[[ToolArgs], str]] = {}

        self._register_default_tools()

    def _register_default_tools(self):
        """기본 도구 등록"""
        self.tool_descriptions["execute_cell"] = lambda args: """
## execute_cell

Execute Python code in a Jupyter cell.

Parameters:
- code (string, required): The Python code to execute
- store_result (boolean, optional): Whether to store the result in a variable

Returns:
- Output from the cell execution
- Any displayed figures or visualizations
"""

        self.tool_descriptions["read_dataframe"] = lambda args: """
## read_dataframe

Read data into a pandas DataFrame.

Parameters:
- path (string, required): Path to the data file
- format (string, optional): File format (csv, excel, parquet, json)
- options (object, optional): Additional read options

Returns:
- DataFrame shape and dtypes
- Preview of first few rows
"""

        self.tool_descriptions["create_visualization"] = lambda args: """
## create_visualization

Create a data visualization.

Parameters:
- data (string, required): Variable name containing the data
- chart_type (string, required): Type of chart (line, bar, scatter, heatmap, etc.)
- options (object, optional): Chart customization options

Returns:
- The rendered visualization
"""

    def get_mode(self, slug: str) -> ModeConfig:
        """모드 설정 가져오기"""
        return self.modes.get(slug, DEFAULT_MODES[0])

    def get_tools_for_mode(self, mode: ModeConfig) -> List[str]:
        """모드에 허용된 도구 목록"""
        # 그룹 기반 도구 결정
        tools = []

        if "read" in mode.groups:
            tools.extend(["read_file", "read_dataframe", "list_files"])
        if "execute" in mode.groups:
            tools.extend(["execute_cell", "run_notebook"])
        if "visualization" in mode.groups:
            tools.extend(["create_visualization", "display_image"])
        if "data" in mode.groups:
            tools.extend(["transform_data", "export_data"])

        return tools

    def get_tool_descriptions_for_mode(
        self,
        mode_slug: str,
        args: ToolArgs
    ) -> str:
        """모드별 도구 설명 생성"""
        mode = self.get_mode(mode_slug)
        tools = self.get_tools_for_mode(mode)

        descriptions = []
        for tool_name in tools:
            if tool_name in self.tool_descriptions:
                desc = self.tool_descriptions[tool_name](args)
                descriptions.append(desc)

        return "\n".join(descriptions)

    async def load_custom_instructions(
        self,
        mode: str,
        global_instructions: str = "",
        language: str = "en"
    ) -> str:
        """커스텀 지시사항 로드"""
        sections = []

        # 언어 설정
        if language != "en":
            sections.append(f"Language: Respond in {language}")

        # 전역 지시사항
        if global_instructions:
            sections.append(f"Global Instructions:\n{global_instructions}")

        # 모드별 지시사항
        mode_config = self.get_mode(mode)
        if mode_config.custom_instructions:
            sections.append(f"Mode Instructions:\n{mode_config.custom_instructions}")

        # 규칙 파일 로드
        rules_paths = [
            Path(self.cwd) / ".jupyter" / "rules",
            Path(self.cwd) / ".roo" / "rules",
            Path(self.cwd) / "AGENTS.md",
        ]

        for path in rules_paths:
            if path.exists():
                if path.is_dir():
                    for rule_file in sorted(path.glob("*.md")):
                        content = rule_file.read_text()
                        sections.append(f"# Rules from {rule_file.name}:\n{content}")
                else:
                    content = path.read_text()
                    sections.append(f"# Rules from {path.name}:\n{content}")

        if sections:
            return f"""
====

CUSTOM INSTRUCTIONS

{chr(10).join(sections)}
"""
        return ""

    async def generate_system_prompt(
        self,
        mode: str = "code",
        global_instructions: str = "",
        language: str = "en",
        include_tools: bool = True,
    ) -> str:
        """시스템 프롬프트 생성"""
        mode_config = self.get_mode(mode)
        gen = self.section_generator

        # 도구 목록
        tools = self.get_tools_for_mode(mode_config) if include_tools else []
        tool_args = ToolArgs(cwd=self.cwd)

        # 프롬프트 조립
        sections = [
            gen.get_role_definition(mode_config),
            gen.get_markdown_formatting_section(),
        ]

        # 도구 설명 (XML 프로토콜용)
        if include_tools and tools:
            tool_section = self.get_tool_descriptions_for_mode(mode, tool_args)
            sections.append(f"# Tools\n{tool_section}")

        sections.extend([
            gen.get_capabilities_section(tools),
            gen.get_rules_section(),
            gen.get_system_info_section(),
            gen.get_objective_section(),
            await self.load_custom_instructions(mode, global_instructions, language),
        ])

        return "\n\n".join(filter(None, sections))


# 사용 예시
async def main():
    prompt_system = JupyterPromptSystem(
        cwd="/home/user/notebooks",
        kernel_name="python3"
    )

    # 기본 코드 모드 프롬프트
    prompt = await prompt_system.generate_system_prompt(
        mode="code",
        language="ko",
        global_instructions="항상 PEP 8 스타일 가이드를 따르세요."
    )

    print(prompt)

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())
```

---

## 아키텍처 비교: Roo-Code vs Jupyter 에이전트

| 구성 요소 | Roo-Code | Jupyter 에이전트 |
|-----------|----------|------------------|
| **프롬프트 생성** | `SYSTEM_PROMPT()` | `generate_system_prompt()` |
| **모드 설정** | `ModeConfig` (TypeScript) | `ModeConfig` (dataclass) |
| **섹션 모듈** | `src/core/prompts/sections/` | `PromptSectionGenerator` |
| **도구 필터링** | 그룹 기반 + 실험 플래그 | 그룹 기반 |
| **커스텀 지시사항** | `.roo/`, `AGENTS.md` | `.jupyter/`, `AGENTS.md` |
| **프로토콜** | XML / Native | XML / Function Calling |
| **변수 치환** | `{{workspace}}`, `{{mode}}` | f-string, Jinja2 |

---

## 핵심 패턴 요약

### 1. 모듈식 섹션 조합
```typescript
basePrompt = `${roleDefinition}
${toolsCatalog}
${rulesSection}
${customInstructions}`
```

### 2. 모드 기반 도구 필터링
```typescript
getToolDescriptionsForMode(mode, ...) // 모드별 허용 도구만 포함
```

### 3. 계층적 지시사항 로딩
```
Global → Mode-specific → Rule files → AGENTS.md
```

### 4. 프로토콜 적응
```typescript
isNativeProtocol(protocol) ? "" : toolsCatalog
```

### 5. 환경 정보 동적 주입
```typescript
getSystemInfoSection(cwd) // OS, 셸, 디렉토리 정보
```

---

## 참고 파일

| 파일 | 설명 |
|------|------|
| `src/core/prompts/system.ts` | 시스템 프롬프트 진입점 |
| `src/core/prompts/sections/` | 프롬프트 섹션 모듈 |
| `src/core/prompts/tools/index.ts` | 도구 설명 생성 |
| `src/core/prompts/tools/native-tools/` | Native 프로토콜 도구 정의 |
| `src/shared/modes.ts` | 모드 설정 및 도구 필터링 |
| `@roo-code/types` | 타입 정의 (ModeConfig 등) |
