# 07. 상태 및 영속성

## 목차
1. [개요](#개요)
2. [ContextProxy 패턴](#contextproxy-패턴)
3. [작업 영속성 시스템](#작업-영속성-시스템)
4. [체크포인트 시스템](#체크포인트-시스템)
5. [히스토리 관리](#히스토리-관리)
6. [설정 관리](#설정-관리)
7. [비파괴적 되감기](#비파괴적-되감기)
8. [Jupyter 노트북 상태 통합](#jupyter-노트북-상태-통합)
9. [구현 가이드](#구현-가이드)

---

## 개요

Roo-Code의 상태 영속성 시스템은 복잡한 AI 작업의 상태를 안정적으로 저장, 복원, 관리하는 다층 아키텍처를 제공합니다.

### 상태 계층 구조

```
┌─────────────────────────────────────────────────────────────────────┐
│                        상태 영속성 계층                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │                    ContextProxy (메모리 캐시)                   │ │
│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐   │ │
│  │  │ GlobalState │  │ SecretState │  │ ProviderSettings    │   │ │
│  │  └─────────────┘  └─────────────┘  └─────────────────────┘   │ │
│  └───────────────────────────────────────────────────────────────┘ │
│                              │                                      │
│                              ▼                                      │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │                VSCode Storage (영속 저장소)                     │ │
│  │  ┌──────────────┐  ┌────────────────┐                        │ │
│  │  │ globalState  │  │    secrets     │                        │ │
│  │  │ (JSON 직렬화) │  │ (암호화 저장)   │                        │ │
│  │  └──────────────┘  └────────────────┘                        │ │
│  └───────────────────────────────────────────────────────────────┘ │
│                              │                                      │
│                              ▼                                      │
│  ┌───────────────────────────────────────────────────────────────┐ │
│  │                Task Persistence (파일 시스템)                   │ │
│  │  globalStorage/                                               │ │
│  │  └── tasks/                                                   │ │
│  │      └── {taskId}/                                           │ │
│  │          ├── ui_messages.json      (UI 히스토리)               │ │
│  │          ├── api_conversation.json (API 히스토리)              │ │
│  │          ├── metadata.json         (메타데이터)                │ │
│  │          └── checkpoints/          (체크포인트)                │ │
│  │              └── .git/             (Shadow Git)               │ │
│  └───────────────────────────────────────────────────────────────┘ │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 핵심 컴포넌트

| 컴포넌트 | 역할 | 저장 위치 |
|---------|------|-----------|
| ContextProxy | 상태 캐시 + Zod 검증 | 메모리 |
| globalState | 일반 설정 | VSCode globalState |
| secrets | API 키 등 민감 정보 | VSCode secrets |
| Task Persistence | 작업별 데이터 | 파일 시스템 |
| Checkpoint | 워크스페이스 스냅샷 | Shadow Git |

---

## ContextProxy 패턴

### 핵심 개념

ContextProxy는 VSCode의 globalState와 secrets를 래핑하여 메모리 캐싱과 Zod 스키마 검증을 제공합니다.

```typescript
// src/core/config/ContextProxy.ts
export class ContextProxy {
  private readonly originalContext: vscode.ExtensionContext
  private stateCache: GlobalState
  private secretCache: SecretState
  private _isInitialized = false

  constructor(context: vscode.ExtensionContext) {
    this.originalContext = context
    this.stateCache = {}
    this.secretCache = {}
  }

  // 초기화: 모든 상태를 캐시로 로드
  public async initialize() {
    // GlobalState 로드
    for (const key of GLOBAL_STATE_KEYS) {
      try {
        this.stateCache[key] = this.originalContext.globalState.get(key)
      } catch (error) {
        logger.error(`Error loading global ${key}: ${error}`)
      }
    }

    // Secrets 로드 (비동기)
    const promises = [
      ...SECRET_STATE_KEYS.map(async (key) => {
        try {
          this.secretCache[key] = await this.originalContext.secrets.get(key)
        } catch (error) {
          logger.error(`Error loading secret ${key}: ${error}`)
        }
      }),
    ]

    await Promise.all(promises)

    // 마이그레이션 실행
    await this.migrateImageGenerationSettings()
    await this.migrateInvalidApiProvider()

    this._isInitialized = true
  }
}
```

### 싱글톤 인스턴스 관리

```typescript
// 싱글톤 패턴으로 전역 접근
private static _instance: ContextProxy | null = null

static get instance() {
  if (!this._instance) {
    throw new Error("ContextProxy not initialized")
  }
  return this._instance
}

static async getInstance(context: vscode.ExtensionContext) {
  if (this._instance) {
    return this._instance
  }

  this._instance = new ContextProxy(context)
  await this._instance.initialize()

  return this._instance
}
```

### 상태 접근 패턴

```typescript
// 캐시 우선 읽기
getGlobalState<K extends GlobalStateKey>(key: K): GlobalState[K] {
  // 특정 키는 직접 접근 (대용량 데이터)
  if (isPassThroughStateKey(key)) {
    return this.originalContext.globalState.get<GlobalState[K]>(key)
  }

  // 일반 키는 캐시에서 읽기
  return this.stateCache[key]
}

// 캐시와 저장소 동시 업데이트
updateGlobalState<K extends GlobalStateKey>(key: K, value: GlobalState[K]) {
  if (isPassThroughStateKey(key)) {
    return this.originalContext.globalState.update(key, value)
  }

  // 캐시 업데이트
  this.stateCache[key] = value
  // 영속 저장소 업데이트
  return this.originalContext.globalState.update(key, value)
}
```

### Zod 스키마 검증

```typescript
// 설정 반환 시 스키마 검증
public getGlobalSettings(): GlobalSettings {
  const values = this.getValues()

  try {
    // Zod 스키마로 검증
    return globalSettingsSchema.parse(values)
  } catch (error) {
    if (error instanceof ZodError) {
      // 텔레메트리에 검증 오류 보고
      TelemetryService.instance.captureSchemaValidationError({
        schemaName: "GlobalSettings",
        error
      })
    }

    // 검증 실패 시 기본 반환
    return GLOBAL_SETTINGS_KEYS.reduce(
      (acc, key) => ({ ...acc, [key]: values[key] }),
      {} as GlobalSettings
    )
  }
}

// Provider 설정 검증 + Sanitization
public getProviderSettings(): ProviderSettings {
  const values = this.getValues()

  // 유효하지 않은 provider 값 정리
  const sanitizedValues = this.sanitizeProviderValues(values)

  try {
    return providerSettingsSchema.parse(sanitizedValues)
  } catch (error) {
    // 오류 처리...
  }
}

private sanitizeProviderValues(values: RooCodeSettings): RooCodeSettings {
  if (values.apiProvider !== undefined && !isProviderName(values.apiProvider)) {
    logger.info(`Sanitizing invalid provider "${values.apiProvider}"`)
    const { apiProvider, ...restValues } = values
    return restValues as RooCodeSettings
  }
  return values
}
```

### 상태 캐시 다이어그램

```
┌─────────────────────────────────────────────────────────────────────┐
│                      ContextProxy 동작 흐름                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   getValue(key)                   setValue(key, value)              │
│        │                                │                           │
│        ▼                                ▼                           │
│   ┌─────────────┐               ┌─────────────┐                    │
│   │ isSecretKey?│               │ isSecretKey?│                    │
│   └──────┬──────┘               └──────┬──────┘                    │
│          │                             │                           │
│    Yes   │   No                  Yes   │   No                      │
│    ┌─────┴─────┐                 ┌─────┴─────┐                     │
│    ▼           ▼                 ▼           ▼                     │
│ secretCache  stateCache     storeSecret  updateGlobalState        │
│    │           │                 │           │                     │
│    │           │                 ▼           ▼                     │
│    │           │            ┌─────────────────────┐                │
│    │           │            │ 캐시 업데이트        │                │
│    │           │            └──────────┬──────────┘                │
│    │           │                       │                           │
│    │           │                       ▼                           │
│    │           │            ┌─────────────────────┐                │
│    │           │            │ 영속 저장소 업데이트  │                │
│    │           │            │ (VSCode API)        │                │
│    │           │            └─────────────────────┘                │
│    │           │                                                   │
│    ▼           ▼                                                   │
│  값 반환    값 반환                                                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 작업 영속성 시스템

### 파일 구조

```
globalStorage/
└── tasks/
    └── {taskId}/
        ├── ui_messages.json         # ClineMessage[] - UI 표시용
        ├── api_conversation.json    # ApiMessage[] - API 전송용
        ├── metadata.json            # TaskMetadata
        └── checkpoints/             # 체크포인트 디렉토리
            └── .git/                # Shadow Git 저장소
```

### UI 메시지 저장

```typescript
// src/core/task-persistence/taskMessages.ts

export type ReadTaskMessagesOptions = {
  taskId: string
  globalStoragePath: string
}

export async function readTaskMessages({
  taskId,
  globalStoragePath,
}: ReadTaskMessagesOptions): Promise<ClineMessage[]> {
  const taskDir = await getTaskDirectoryPath(globalStoragePath, taskId)
  const filePath = path.join(taskDir, GlobalFileNames.uiMessages)
  const fileExists = await fileExistsAtPath(filePath)

  if (fileExists) {
    return JSON.parse(await fs.readFile(filePath, "utf8"))
  }

  return []
}

export async function saveTaskMessages({
  messages,
  taskId,
  globalStoragePath,
}: SaveTaskMessagesOptions) {
  const taskDir = await getTaskDirectoryPath(globalStoragePath, taskId)
  const filePath = path.join(taskDir, GlobalFileNames.uiMessages)

  // 안전한 JSON 쓰기 (원자성 보장)
  await safeWriteJson(filePath, messages)
}
```

### API 메시지 저장

```typescript
// src/core/task-persistence/apiMessages.ts

// API 메시지 확장 타입
export type ApiMessage = Anthropic.MessageParam & {
  ts?: number                    // 타임스탬프
  isSummary?: boolean            // 압축 요약 메시지
  id?: string                    // 고유 ID
  type?: "reasoning"             // 추론 타입
  summary?: any[]                // 요약 데이터
  encrypted_content?: string     // 암호화된 콘텐츠
  text?: string                  // 텍스트 콘텐츠

  // 비파괴적 압축 관련
  condenseId?: string            // 요약 메시지 식별자
  condenseParent?: string        // 이 메시지를 대체하는 요약의 ID

  // 비파괴적 잘라내기 관련
  truncationId?: string          // 잘라내기 마커 식별자
  truncationParent?: string      // 이 메시지를 숨기는 마커의 ID
  isTruncationMarker?: boolean   // 잘라내기 경계 마커
}

export async function readApiMessages({
  taskId,
  globalStoragePath,
}: {
  taskId: string
  globalStoragePath: string
}): Promise<ApiMessage[]> {
  const taskDir = await getTaskDirectoryPath(globalStoragePath, taskId)
  const filePath = path.join(taskDir, GlobalFileNames.apiConversationHistory)

  if (await fileExistsAtPath(filePath)) {
    return JSON.parse(await fs.readFile(filePath, "utf8"))
  }

  // 레거시 파일 마이그레이션
  const oldPath = path.join(taskDir, "claude_messages.json")
  if (await fileExistsAtPath(oldPath)) {
    const data = JSON.parse(await fs.readFile(oldPath, "utf8"))
    await fs.unlink(oldPath)  // 이전 파일 삭제
    return data
  }

  return []
}

export async function saveApiMessages({
  messages,
  taskId,
  globalStoragePath,
}: {
  messages: ApiMessage[]
  taskId: string
  globalStoragePath: string
}) {
  const taskDir = await getTaskDirectoryPath(globalStoragePath, taskId)
  const filePath = path.join(taskDir, GlobalFileNames.apiConversationHistory)
  await safeWriteJson(filePath, messages)
}
```

### 안전한 파일 쓰기

```typescript
// src/utils/safeWriteJson.ts

export async function safeWriteJson(filePath: string, data: any): Promise<void> {
  const tempPath = `${filePath}.tmp`
  const content = JSON.stringify(data, null, 2)

  try {
    // 1. 임시 파일에 쓰기
    await fs.writeFile(tempPath, content, "utf8")

    // 2. 원자적 이름 변경
    await fs.rename(tempPath, filePath)
  } catch (error) {
    // 임시 파일 정리
    try {
      await fs.unlink(tempPath)
    } catch {
      // 무시
    }
    throw error
  }
}
```

---

## 체크포인트 시스템

### 아키텍처

체크포인트 시스템은 "Shadow Git"을 사용하여 워크스페이스의 상태를 비파괴적으로 저장합니다.

```
┌─────────────────────────────────────────────────────────────────────┐
│                      체크포인트 시스템 아키텍처                        │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   워크스페이스                      Shadow Git                       │
│   ┌─────────────────┐             ┌─────────────────┐              │
│   │ /project/       │             │ globalStorage/  │              │
│   │   src/          │  ◄──────►   │   tasks/        │              │
│   │   package.json  │  git add/   │     {taskId}/   │              │
│   │   ...           │  commit     │       checkpoints/             │
│   └─────────────────┘             │         .git/   │              │
│         │                         └─────────────────┘              │
│         │                                │                          │
│         │ core.worktree 설정              │                          │
│         └────────────────────────────────┘                          │
│                                                                     │
│   체크포인트 생성 흐름:                                               │
│   1. git add . (모든 변경 스테이징)                                   │
│   2. git commit (체크포인트 저장)                                    │
│   3. emit("checkpoint") → UI 알림                                   │
│                                                                     │
│   체크포인트 복원 흐름:                                               │
│   1. git clean -fd (작업 파일 정리)                                  │
│   2. git reset --hard {hash} (체크포인트로 복원)                     │
│   3. MessageManager.rewindToTimestamp() (히스토리 동기화)            │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### ShadowCheckpointService

```typescript
// src/services/checkpoints/ShadowCheckpointService.ts

export abstract class ShadowCheckpointService extends EventEmitter {
  public readonly taskId: string
  public readonly checkpointsDir: string
  public readonly workspaceDir: string

  protected _checkpoints: string[] = []
  protected _baseHash?: string
  protected git?: SimpleGit

  public get isInitialized() {
    return !!this.git
  }

  public getCheckpoints(): string[] {
    return this._checkpoints.slice()
  }

  constructor(
    taskId: string,
    checkpointsDir: string,
    workspaceDir: string,
    log: (message: string) => void
  ) {
    super()

    // 보호된 경로 검증
    const protectedPaths = [
      os.homedir(),
      path.join(os.homedir(), "Desktop"),
      path.join(os.homedir(), "Documents"),
      path.join(os.homedir(), "Downloads"),
    ]

    if (protectedPaths.includes(workspaceDir)) {
      throw new Error(`Cannot use checkpoints in ${workspaceDir}`)
    }

    this.taskId = taskId
    this.checkpointsDir = checkpointsDir
    this.workspaceDir = workspaceDir
    this.dotGitDir = path.join(this.checkpointsDir, ".git")
    this.log = log
  }
}
```

### Shadow Git 초기화

```typescript
public async initShadowGit(onInit?: () => Promise<void>) {
  if (this.git) {
    throw new Error("Shadow git repo already initialized")
  }

  // 중첩 Git 저장소 검사
  const nestedGitPath = await this.getNestedGitRepository()
  if (nestedGitPath) {
    throw new Error(`Nested git repository detected at: ${nestedGitPath}`)
  }

  await fs.mkdir(this.checkpointsDir, { recursive: true })
  const git = createSanitizedGit(this.checkpointsDir)

  if (await fileExistsAtPath(this.dotGitDir)) {
    // 기존 저장소 검증
    const worktree = await this.getShadowGitConfigWorktree(git)
    if (worktree !== this.workspaceDir) {
      throw new Error(`Workspace mismatch: ${worktree} !== ${this.workspaceDir}`)
    }

    await this.writeExcludeFile()
    this.baseHash = await git.revparse(["HEAD"])
  } else {
    // 새 저장소 생성
    await git.init()
    await git.addConfig("core.worktree", this.workspaceDir)
    await git.addConfig("commit.gpgSign", "false")
    await git.addConfig("user.name", "Roo Code")
    await git.addConfig("user.email", "noreply@example.com")
    await this.writeExcludeFile()
    await this.stageAll(git)

    const { commit } = await git.commit("initial commit", { "--allow-empty": null })
    this.baseHash = commit
  }

  this.git = git
  await onInit?.()

  this.emit("initialize", {
    type: "initialize",
    workspaceDir: this.workspaceDir,
    baseHash: this.baseHash,
  })
}
```

### 체크포인트 저장

```typescript
public async saveCheckpoint(
  message: string,
  options?: { allowEmpty?: boolean; suppressMessage?: boolean }
): Promise<CheckpointResult | undefined> {
  if (!this.git) {
    throw new Error("Shadow git repo not initialized")
  }

  const startTime = Date.now()

  // 모든 변경 스테이징
  await this.stageAll(this.git)

  // 커밋 생성
  const commitArgs = options?.allowEmpty ? { "--allow-empty": null } : undefined
  const result = await this.git.commit(message, commitArgs)

  const fromHash = this._checkpoints[this._checkpoints.length - 1] ?? this.baseHash!
  const toHash = result.commit || fromHash
  this._checkpoints.push(toHash)

  const duration = Date.now() - startTime

  if (result.commit) {
    // 체크포인트 이벤트 발생
    this.emit("checkpoint", {
      type: "checkpoint",
      fromHash,
      toHash,
      duration,
      suppressMessage: options?.suppressMessage ?? false,
    })

    return result
  }

  return undefined
}
```

### 체크포인트 복원

```typescript
public async restoreCheckpoint(commitHash: string) {
  if (!this.git) {
    throw new Error("Shadow git repo not initialized")
  }

  const start = Date.now()

  // 워크스페이스 정리
  await this.git.clean("f", ["-d", "-f"])

  // 체크포인트로 복원
  await this.git.reset(["--hard", commitHash])

  // 체크포인트 목록 정리
  const checkpointIndex = this._checkpoints.indexOf(commitHash)
  if (checkpointIndex !== -1) {
    this._checkpoints = this._checkpoints.slice(0, checkpointIndex + 1)
  }

  const duration = Date.now() - start
  this.emit("restore", { type: "restore", commitHash, duration })
}
```

### 체크포인트 Diff

```typescript
public async getDiff({ from, to }: { from?: string; to?: string }): Promise<CheckpointDiff[]> {
  if (!this.git) {
    throw new Error("Shadow git repo not initialized")
  }

  const result = []

  if (!from) {
    // 첫 번째 커밋 해시 가져오기
    from = (await this.git.raw(["rev-list", "--max-parents=0", "HEAD"])).trim()
  }

  // 변경 사항 스테이징
  await this.stageAll(this.git)

  // 차이점 요약 가져오기
  const { files } = to
    ? await this.git.diffSummary([`${from}..${to}`])
    : await this.git.diffSummary([from])

  const cwdPath = await this.getShadowGitConfigWorktree(this.git) || this.workspaceDir

  for (const file of files) {
    const relPath = file.file
    const absPath = path.join(cwdPath, relPath)

    // 이전/이후 내용 가져오기
    const before = await this.git.show([`${from}:${relPath}`]).catch(() => "")
    const after = to
      ? await this.git.show([`${to}:${relPath}`]).catch(() => "")
      : await fs.readFile(absPath, "utf8").catch(() => "")

    result.push({
      paths: { relative: relPath, absolute: absPath },
      content: { before, after }
    })
  }

  return result
}
```

---

## 히스토리 관리

### HistoryItem 구조

```typescript
// packages/types/src/history.ts

export const historyItemSchema = z.object({
  id: z.string(),                      // 작업 ID
  rootTaskId: z.string().optional(),   // 루트 작업 ID (서브태스크인 경우)
  parentTaskId: z.string().optional(), // 부모 작업 ID
  number: z.number(),                  // 작업 번호
  ts: z.number(),                      // 타임스탬프
  task: z.string(),                    // 작업 설명
  tokensIn: z.number(),                // 입력 토큰
  tokensOut: z.number(),               // 출력 토큰
  cacheWrites: z.number().optional(),  // 캐시 쓰기
  cacheReads: z.number().optional(),   // 캐시 읽기
  totalCost: z.number(),               // 총 비용
  size: z.number().optional(),         // 크기
  workspace: z.string().optional(),    // 워크스페이스 경로
  mode: z.string().optional(),         // 모드

  // 상태 관리
  status: z.enum(["active", "completed", "delegated"]).optional(),

  // 서브태스크 관계
  delegatedToId: z.string().optional(),     // 위임된 자식 ID
  childIds: z.array(z.string()).optional(), // 모든 자식 ID
  awaitingChildId: z.string().optional(),   // 현재 대기 중인 자식
  completedByChildId: z.string().optional(), // 완료한 자식 ID
  completionResultSummary: z.string().optional(), // 완료 요약
})

export type HistoryItem = z.infer<typeof historyItemSchema>
```

### 히스토리 계층 구조

```
┌─────────────────────────────────────────────────────────────────────┐
│                        히스토리 계층 구조                             │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   Root Task (id: "task-001")                                       │
│   ├── status: "active"                                             │
│   ├── childIds: ["task-002", "task-003"]                          │
│   └── awaitingChildId: "task-002"                                  │
│       │                                                            │
│       ├── Child Task (id: "task-002")                              │
│       │   ├── status: "completed"                                  │
│       │   ├── rootTaskId: "task-001"                               │
│       │   ├── parentTaskId: "task-001"                             │
│       │   └── completionResultSummary: "분석 완료"                  │
│       │                                                            │
│       └── Child Task (id: "task-003")                              │
│           ├── status: "active"                                     │
│           ├── rootTaskId: "task-001"                               │
│           └── parentTaskId: "task-001"                             │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 설정 관리

### 설정 키 분류

```typescript
// packages/types/src/global-settings.ts

// 일반 상태 키
export const GLOBAL_STATE_KEYS = [
  "apiProvider",
  "apiModelId",
  "customInstructions",
  "autoApprovalEnabled",
  "alwaysAllowReadOnly",
  "alwaysAllowWrite",
  "alwaysAllowExecute",
  "browserToolEnabled",
  "mcpEnabled",
  "mode",
  "customModes",
  "experiments",
  "taskHistory",
  // ... 100+ 설정 키
]

// 비밀 상태 키 (암호화 저장)
export const SECRET_STATE_KEYS = [
  "apiKey",
  "openRouterApiKey",
  "awsAccessKey",
  "awsSecretKey",
  "gcpKeyFile",
  "openAiApiKey",
  "geminiApiKey",
  // ... 민감 정보
]

// Provider 설정 키
export const PROVIDER_SETTINGS_KEYS = [
  "apiProvider",
  "apiModelId",
  "apiKey",
  "awsRegion",
  "awsAccessKey",
  "openRouterModelInfo",
  // ... Provider 관련 설정
]
```

### 설정 내보내기/가져오기

```typescript
// ContextProxy에서 설정 내보내기
public async export(): Promise<GlobalSettings | undefined> {
  try {
    // 내보내기용 스키마 (히스토리 등 제외)
    const globalSettings = globalSettingsExportSchema.parse(this.getValues())

    // 프로젝트 모드는 제외 (글로벌 모드만 내보내기)
    globalSettings.customModes = globalSettings.customModes?.filter(
      (mode) => mode.source === "global"
    )

    // undefined 값 제거
    return Object.fromEntries(
      Object.entries(globalSettings).filter(([_, value]) => value !== undefined)
    )
  } catch (error) {
    return undefined
  }
}

// 모든 상태 초기화
public async resetAllState() {
  // 메모리 캐시 초기화
  this.stateCache = {}
  this.secretCache = {}

  // 영속 저장소 초기화
  await Promise.all([
    ...GLOBAL_STATE_KEYS.map((key) =>
      this.originalContext.globalState.update(key, undefined)
    ),
    ...SECRET_STATE_KEYS.map((key) =>
      this.originalContext.secrets.delete(key)
    ),
  ])

  // 재초기화
  await this.initialize()
}
```

---

## 비파괴적 되감기

### 마커 기반 히스토리 관리

```typescript
// 비파괴적 압축 마커
export type ApiMessage = Anthropic.MessageParam & {
  // 압축 요약 메시지 식별자
  condenseId?: string

  // 이 메시지를 대체하는 요약의 ID
  // condenseParent가 있으면 API 전송 시 필터링됨
  condenseParent?: string

  // 잘라내기 마커 식별자
  truncationId?: string

  // 이 메시지를 숨기는 마커의 ID
  truncationParent?: string

  // 잘라내기 경계 마커 여부
  isTruncationMarker?: boolean
}
```

### 비파괴적 압축 흐름

```
┌─────────────────────────────────────────────────────────────────────┐
│                      비파괴적 압축 프로세스                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   Before Condense:                                                  │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ API History:                                                │  │
│   │ [msg1, msg2, msg3, msg4, msg5, msg6]                       │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                     │
│   After Condense (비파괴적):                                        │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ API History (저장):                                         │  │
│   │ [                                                           │  │
│   │   msg1 { condenseParent: "summary-A" },  ← 숨김               │
│   │   msg2 { condenseParent: "summary-A" },  ← 숨김               │
│   │   msg3 { condenseParent: "summary-A" },  ← 숨김               │
│   │   SUMMARY { condenseId: "summary-A", isSummary: true },      │
│   │   msg4,                                                     │
│   │   msg5,                                                     │
│   │   msg6                                                      │
│   │ ]                                                           │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                     │
│   API 전송 시 (필터링):                                              │
│   ┌─────────────────────────────────────────────────────────────┐  │
│   │ [SUMMARY, msg4, msg5, msg6]  ← condenseParent 있는 것 제외    │  │
│   └─────────────────────────────────────────────────────────────┘  │
│                                                                     │
│   되감기 시:                                                        │
│   - condenseParent 제거 → 원본 메시지 복원                           │
│   - SUMMARY 삭제 → 요약 제거                                        │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 고아 메시지 정리

```typescript
// MessageManager에서 고아 메시지 처리
private async truncateApiHistoryWithCleanup(
  cutoffTs: number,
  removedIds: ContextEventIds,
  skipCleanup: boolean
): Promise<void> {
  let apiHistory = [...this.task.apiConversationHistory]

  // 1. 타임스탬프로 필터
  apiHistory = apiHistory.filter((m) => !m.ts || m.ts < cutoffTs)

  // 2. 고아 Summary 제거 (condense_context가 삭제된 경우)
  if (removedIds.condenseIds.size > 0) {
    apiHistory = apiHistory.filter((msg) => {
      if (msg.isSummary && msg.condenseId && removedIds.condenseIds.has(msg.condenseId)) {
        console.log(`Removing orphaned Summary: ${msg.condenseId}`)
        return false
      }
      return true
    })
  }

  // 3. 고아 truncation marker 제거
  if (removedIds.truncationIds.size > 0) {
    apiHistory = apiHistory.filter((msg) => {
      if (msg.isTruncationMarker && msg.truncationId &&
          removedIds.truncationIds.has(msg.truncationId)) {
        console.log(`Removing orphaned truncation marker: ${msg.truncationId}`)
        return false
      }
      return true
    })
  }

  // 4. 추가 정리
  if (!skipCleanup) {
    apiHistory = cleanupAfterTruncation(apiHistory)
  }

  await this.task.overwriteApiConversationHistory(apiHistory)
}
```

---

## Jupyter 노트북 상태 통합

### 아키텍처 매핑

| Roo-Code | Jupyter | 설명 |
|----------|---------|------|
| ContextProxy | ConfigManager | 설정 캐시 및 검증 |
| globalState | jupyter_config.py | 일반 설정 |
| secrets | keyring/환경변수 | 민감 정보 |
| Task Persistence | Notebook 메타데이터 | 작업 데이터 |
| Checkpoint | nbformat 셀 메타데이터 | 상태 스냅샷 |

### Jupyter 통합 전략

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Jupyter 상태 통합 전략                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│   ┌───────────────────────────────────────────────────────────────┐│
│   │                   노트북 메타데이터 저장소                       ││
│   │                                                               ││
│   │   notebook.ipynb:                                             ││
│   │   {                                                           ││
│   │     "metadata": {                                             ││
│   │       "hdsp_agent": {                                         ││
│   │         "task_id": "task-001",                                ││
│   │         "messages": [...],                                    ││
│   │         "api_history": [...],                                 ││
│   │         "checkpoints": [                                      ││
│   │           {"ts": 1234567890, "cell_index": 5, "hash": "abc"}  ││
│   │         ]                                                     ││
│   │       }                                                       ││
│   │     }                                                         ││
│   │   }                                                           ││
│   └───────────────────────────────────────────────────────────────┘│
│                                                                     │
│   ┌───────────────────────────────────────────────────────────────┐│
│   │                     셀별 상태 저장                              ││
│   │                                                               ││
│   │   cell.metadata = {                                           ││
│   │     "hdsp_checkpoint": {                                      ││
│   │       "ts": 1234567890,                                       ││
│   │       "state_hash": "abc123",                                 ││
│   │       "variables": ["df", "model"]                            ││
│   │     }                                                         ││
│   │   }                                                           ││
│   └───────────────────────────────────────────────────────────────┘│
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 구현 가이드

### Python ContextProxy 구현

```python
# hdsp_agent/config/context_proxy.py
from typing import Dict, Any, Optional, TypeVar, Generic, Set
from dataclasses import dataclass, field
from pathlib import Path
import json
import os
from pydantic import BaseModel, ValidationError
import keyring

T = TypeVar('T')


class GlobalState(BaseModel):
    """전역 상태 스키마"""
    api_provider: Optional[str] = None
    api_model_id: Optional[str] = None
    custom_instructions: Optional[str] = None
    auto_approval_enabled: bool = False
    mode: str = "code"
    experiments: Dict[str, bool] = field(default_factory=dict)
    # ... 추가 설정


class SecretState(BaseModel):
    """비밀 상태 (민감 정보)"""
    api_key: Optional[str] = None
    openai_api_key: Optional[str] = None
    anthropic_api_key: Optional[str] = None


# 키 분류
GLOBAL_STATE_KEYS: Set[str] = {
    "api_provider", "api_model_id", "custom_instructions",
    "auto_approval_enabled", "mode", "experiments"
}

SECRET_STATE_KEYS: Set[str] = {
    "api_key", "openai_api_key", "anthropic_api_key"
}

PASS_THROUGH_KEYS: Set[str] = {"task_history"}


class ContextProxy:
    """상태 관리 프록시 - 캐시 및 Pydantic 검증"""

    _instance: Optional["ContextProxy"] = None

    def __init__(self, config_dir: Path):
        self._config_dir = config_dir
        self._config_file = config_dir / "config.json"
        self._state_cache: Dict[str, Any] = {}
        self._secret_cache: Dict[str, Any] = {}
        self._is_initialized = False
        self._keyring_service = "hdsp-agent"

    @classmethod
    def get_instance(cls, config_dir: Optional[Path] = None) -> "ContextProxy":
        """싱글톤 인스턴스 반환"""
        if cls._instance is None:
            if config_dir is None:
                config_dir = Path.home() / ".hdsp-agent"
            cls._instance = cls(config_dir)
        return cls._instance

    async def initialize(self) -> None:
        """초기화 - 파일 및 키링에서 상태 로드"""
        if self._is_initialized:
            return

        # 설정 디렉토리 생성
        self._config_dir.mkdir(parents=True, exist_ok=True)

        # 파일에서 상태 로드
        if self._config_file.exists():
            with open(self._config_file, 'r') as f:
                data = json.load(f)
                for key in GLOBAL_STATE_KEYS:
                    if key in data:
                        self._state_cache[key] = data[key]

        # 키링에서 비밀 로드
        for key in SECRET_STATE_KEYS:
            try:
                value = keyring.get_password(self._keyring_service, key)
                if value:
                    self._secret_cache[key] = value
            except Exception as e:
                print(f"Error loading secret {key}: {e}")

        self._is_initialized = True

    @property
    def is_initialized(self) -> bool:
        return self._is_initialized

    # 상태 접근 메서드
    def get_value(self, key: str) -> Any:
        """키에 해당하는 값 반환"""
        if key in SECRET_STATE_KEYS:
            return self._secret_cache.get(key)
        return self._state_cache.get(key)

    async def set_value(self, key: str, value: Any) -> None:
        """키에 값 설정"""
        if key in SECRET_STATE_KEYS:
            self._secret_cache[key] = value
            if value is None:
                keyring.delete_password(self._keyring_service, key)
            else:
                keyring.set_password(self._keyring_service, key, value)
        else:
            self._state_cache[key] = value
            await self._save_state()

    async def _save_state(self) -> None:
        """상태를 파일에 저장"""
        with open(self._config_file, 'w') as f:
            json.dump(self._state_cache, f, indent=2)

    def get_global_settings(self) -> GlobalState:
        """Pydantic 검증된 전역 설정 반환"""
        try:
            return GlobalState(**self._state_cache)
        except ValidationError as e:
            print(f"Validation error: {e}")
            return GlobalState()

    async def export_settings(self) -> Dict[str, Any]:
        """설정 내보내기 (비밀 제외)"""
        return {k: v for k, v in self._state_cache.items()
                if k not in PASS_THROUGH_KEYS and v is not None}

    async def reset_all_state(self) -> None:
        """모든 상태 초기화"""
        self._state_cache = {}
        self._secret_cache = {}

        # 파일 삭제
        if self._config_file.exists():
            self._config_file.unlink()

        # 키링 정리
        for key in SECRET_STATE_KEYS:
            try:
                keyring.delete_password(self._keyring_service, key)
            except:
                pass

        await self.initialize()
```

### Python 작업 영속성

```python
# hdsp_agent/persistence/task_storage.py
from typing import List, Dict, Any, Optional
from dataclasses import dataclass
from pathlib import Path
import json
import asyncio
from datetime import datetime


@dataclass
class TaskPaths:
    """작업 파일 경로"""
    base_dir: Path
    ui_messages: Path
    api_history: Path
    metadata: Path
    checkpoints: Path

    @classmethod
    def for_task(cls, storage_dir: Path, task_id: str) -> "TaskPaths":
        base = storage_dir / "tasks" / task_id
        return cls(
            base_dir=base,
            ui_messages=base / "ui_messages.json",
            api_history=base / "api_conversation.json",
            metadata=base / "metadata.json",
            checkpoints=base / "checkpoints"
        )


class TaskStorage:
    """작업 데이터 영속성 관리"""

    def __init__(self, storage_dir: Path):
        self.storage_dir = storage_dir

    def _get_paths(self, task_id: str) -> TaskPaths:
        return TaskPaths.for_task(self.storage_dir, task_id)

    async def save_ui_messages(
        self,
        task_id: str,
        messages: List[Dict[str, Any]]
    ) -> None:
        """UI 메시지 저장"""
        paths = self._get_paths(task_id)
        paths.base_dir.mkdir(parents=True, exist_ok=True)
        await self._safe_write_json(paths.ui_messages, messages)

    async def load_ui_messages(
        self,
        task_id: str
    ) -> List[Dict[str, Any]]:
        """UI 메시지 로드"""
        paths = self._get_paths(task_id)
        if paths.ui_messages.exists():
            with open(paths.ui_messages, 'r') as f:
                return json.load(f)
        return []

    async def save_api_history(
        self,
        task_id: str,
        history: List[Dict[str, Any]]
    ) -> None:
        """API 히스토리 저장"""
        paths = self._get_paths(task_id)
        paths.base_dir.mkdir(parents=True, exist_ok=True)
        await self._safe_write_json(paths.api_history, history)

    async def load_api_history(
        self,
        task_id: str
    ) -> List[Dict[str, Any]]:
        """API 히스토리 로드"""
        paths = self._get_paths(task_id)
        if paths.api_history.exists():
            with open(paths.api_history, 'r') as f:
                return json.load(f)
        return []

    async def _safe_write_json(
        self,
        path: Path,
        data: Any
    ) -> None:
        """안전한 JSON 쓰기 (원자적)"""
        temp_path = path.with_suffix('.tmp')
        try:
            with open(temp_path, 'w') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            temp_path.rename(path)
        except Exception:
            if temp_path.exists():
                temp_path.unlink()
            raise


class HistoryManager:
    """히스토리 항목 관리"""

    def __init__(self, storage: TaskStorage):
        self.storage = storage
        self._history_file = storage.storage_dir / "task_history.json"

    async def add_task(self, item: Dict[str, Any]) -> None:
        """새 작업 추가"""
        history = await self.load_history()
        history.append(item)
        await self._save_history(history)

    async def update_task(self, task_id: str, updates: Dict[str, Any]) -> None:
        """작업 정보 업데이트"""
        history = await self.load_history()
        for item in history:
            if item.get("id") == task_id:
                item.update(updates)
                break
        await self._save_history(history)

    async def load_history(self) -> List[Dict[str, Any]]:
        """히스토리 로드"""
        if self._history_file.exists():
            with open(self._history_file, 'r') as f:
                return json.load(f)
        return []

    async def _save_history(self, history: List[Dict[str, Any]]) -> None:
        """히스토리 저장"""
        with open(self._history_file, 'w') as f:
            json.dump(history, f, indent=2, ensure_ascii=False)
```

### Python Notebook 체크포인트

```python
# hdsp_agent/persistence/notebook_checkpoint.py
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
from datetime import datetime
import hashlib
import nbformat
from nbformat.v4 import new_notebook, new_code_cell, new_markdown_cell


@dataclass
class CellCheckpoint:
    """셀 체크포인트"""
    timestamp: float
    cell_index: int
    state_hash: str
    variables: List[str]


@dataclass
class NotebookState:
    """노트북 상태"""
    task_id: str
    messages: List[Dict[str, Any]]
    api_history: List[Dict[str, Any]]
    checkpoints: List[CellCheckpoint]


class NotebookCheckpointService:
    """Jupyter 노트북 기반 체크포인트 서비스"""

    METADATA_KEY = "hdsp_agent"
    CELL_METADATA_KEY = "hdsp_checkpoint"

    def __init__(self, notebook_path: str):
        self.notebook_path = notebook_path
        self._notebook: Optional[nbformat.NotebookNode] = None

    async def load_notebook(self) -> None:
        """노트북 로드"""
        with open(self.notebook_path, 'r') as f:
            self._notebook = nbformat.read(f, as_version=4)

    async def save_notebook(self) -> None:
        """노트북 저장"""
        if self._notebook:
            with open(self.notebook_path, 'w') as f:
                nbformat.write(self._notebook, f)

    def get_state(self) -> Optional[NotebookState]:
        """노트북에서 에이전트 상태 로드"""
        if not self._notebook:
            return None

        metadata = self._notebook.metadata.get(self.METADATA_KEY, {})
        if not metadata:
            return None

        checkpoints = [
            CellCheckpoint(**cp)
            for cp in metadata.get("checkpoints", [])
        ]

        return NotebookState(
            task_id=metadata.get("task_id", ""),
            messages=metadata.get("messages", []),
            api_history=metadata.get("api_history", []),
            checkpoints=checkpoints
        )

    async def save_state(self, state: NotebookState) -> None:
        """노트북에 에이전트 상태 저장"""
        if not self._notebook:
            self._notebook = new_notebook()

        self._notebook.metadata[self.METADATA_KEY] = {
            "task_id": state.task_id,
            "messages": state.messages,
            "api_history": state.api_history,
            "checkpoints": [
                {
                    "timestamp": cp.timestamp,
                    "cell_index": cp.cell_index,
                    "state_hash": cp.state_hash,
                    "variables": cp.variables
                }
                for cp in state.checkpoints
            ]
        }

        await self.save_notebook()

    async def create_checkpoint(
        self,
        cell_index: int,
        variables: List[str],
        kernel_state: Dict[str, Any]
    ) -> CellCheckpoint:
        """셀 실행 후 체크포인트 생성"""
        timestamp = datetime.now().timestamp()

        # 상태 해시 계산
        state_str = str(sorted(kernel_state.items()))
        state_hash = hashlib.sha256(state_str.encode()).hexdigest()[:8]

        checkpoint = CellCheckpoint(
            timestamp=timestamp,
            cell_index=cell_index,
            state_hash=state_hash,
            variables=variables
        )

        # 셀 메타데이터에 체크포인트 정보 저장
        if self._notebook and cell_index < len(self._notebook.cells):
            self._notebook.cells[cell_index].metadata[self.CELL_METADATA_KEY] = {
                "timestamp": timestamp,
                "state_hash": state_hash,
                "variables": variables
            }

        return checkpoint

    async def restore_checkpoint(
        self,
        checkpoint: CellCheckpoint,
        kernel_client
    ) -> None:
        """체크포인트로 복원"""
        # 지정된 셀 인덱스까지의 셀 재실행
        for i in range(checkpoint.cell_index + 1):
            if self._notebook and i < len(self._notebook.cells):
                cell = self._notebook.cells[i]
                if cell.cell_type == 'code':
                    # 셀 실행
                    kernel_client.execute(cell.source)

    def get_checkpoints_after(self, timestamp: float) -> List[CellCheckpoint]:
        """특정 시점 이후의 체크포인트 반환"""
        state = self.get_state()
        if not state:
            return []

        return [cp for cp in state.checkpoints if cp.timestamp > timestamp]
```

### 통합 사용 예제

```python
# hdsp_agent/main.py
import asyncio
from pathlib import Path

from .config.context_proxy import ContextProxy
from .persistence.task_storage import TaskStorage, HistoryManager
from .persistence.notebook_checkpoint import NotebookCheckpointService


async def main():
    # 설정 초기화
    config_dir = Path.home() / ".hdsp-agent"
    context = ContextProxy.get_instance(config_dir)
    await context.initialize()

    # 작업 저장소 초기화
    storage = TaskStorage(config_dir)
    history_manager = HistoryManager(storage)

    # 노트북 체크포인트 서비스
    checkpoint_service = NotebookCheckpointService("analysis.ipynb")
    await checkpoint_service.load_notebook()

    # 설정 읽기
    settings = context.get_global_settings()
    print(f"Mode: {settings.mode}")
    print(f"Auto Approval: {settings.auto_approval_enabled}")

    # 작업 생성
    task_id = "task-001"
    await history_manager.add_task({
        "id": task_id,
        "ts": asyncio.get_event_loop().time(),
        "task": "데이터 분석",
        "status": "active"
    })

    # 메시지 저장
    messages = [
        {"ts": 1234567890, "type": "say", "say": "text", "text": "분석 시작"}
    ]
    await storage.save_ui_messages(task_id, messages)

    # 체크포인트 생성
    checkpoint = await checkpoint_service.create_checkpoint(
        cell_index=5,
        variables=["df", "model"],
        kernel_state={"df": "DataFrame", "model": "LogisticRegression"}
    )
    print(f"Checkpoint created: {checkpoint.state_hash}")

    # 설정 변경
    await context.set_value("mode", "architect")

    # 설정 내보내기
    exported = await context.export_settings()
    print(f"Exported settings: {exported}")


if __name__ == "__main__":
    asyncio.run(main())
```

---

## 핵심 패턴 요약

### 1. 캐시 + 영속성 분리

- 메모리 캐시로 빠른 읽기
- 영속 저장소로 내구성 보장
- 동기화는 쓰기 시점에 수행

### 2. 스키마 검증

- Zod/Pydantic으로 런타임 검증
- 마이그레이션으로 호환성 유지
- Sanitization으로 잘못된 데이터 정리

### 3. 원자적 파일 쓰기

- 임시 파일 → 이름 변경 패턴
- 중단 시 데이터 손실 방지

### 4. 비파괴적 히스토리

- 마커 기반으로 숨김/표시 제어
- 원본 데이터 보존
- 되감기 시 완전 복원 가능

### 5. Shadow Git 체크포인트

- 워크스페이스 외부에 저장
- Git 기능 활용 (diff, restore)
- 보호된 경로 제외

---

## 참고 자료

- ContextProxy: `src/core/config/ContextProxy.ts`
- Task Persistence: `src/core/task-persistence/`
- Checkpoint Service: `src/services/checkpoints/`
- History Types: `packages/types/src/history.ts`
- Jupyter nbformat: https://nbformat.readthedocs.io/
